<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>swift project – Programming know how</title><link>https://swift-project.github.io/docs/knowhow/programming/</link><description>Recent content in Programming know how on swift project</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://swift-project.github.io/docs/knowhow/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Building swift</title><link>https://swift-project.github.io/docs/knowhow/programming/swiftbuild/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/swiftbuild/</guid><description/></item><item><title>Docs: C++ trivial objects</title><link>https://swift-project.github.io/docs/knowhow/programming/trivialobjects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/trivialobjects/</guid><description>
&lt;p>From discussion on Discord&lt;/p>
&lt;p>&amp;quot;Primitive&amp;quot; doesn't exist in C++. &amp;quot;Arithmetic types&amp;quot; are like
[bool, double, int]{.title-ref}. &amp;quot;Fundamental types&amp;quot; include
[arithmetics, void]{.title-ref} and [nullptr_t]{.title-ref}.
&amp;quot;Scalars&amp;quot; include arithmetics, [nullptr_t]{.title-ref} and pointers.&lt;/p>
&lt;p>All scalars are trivial, but some non-scalars are also trivial. There is
no &amp;quot;quick&amp;quot; way to see if a class is trivial. You need to look at its
member variables, and its copy ctor, operator=, and dtor. If the member
vars are all trivial, and the copy ctor, operator= and dtor are all
=default then the class is trivial. You can also check:&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">static_assert(std::is_trivial&amp;lt;MyClass&amp;gt;{}, &amp;quot;blah&amp;quot;);
&lt;/code>&lt;/pre>&lt;p>For me, trivial is an &amp;quot;easy&amp;quot; way to say whether a class doesn't need
to be passed by reference. Other trivial classes include
[QStringView]{.title-ref} and [QLatin1String]{.title-ref}.&lt;/p>
&lt;p>The performance cost of pass-by-reference is that the compiler has fewer
optimization opportunities, because it has to assume that the value
could be changed by external code.&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">void throwBall(double value, const CLengthUnit &amp;amp;unit)
{
hand.hold(ball);
arm.prepareThrow(value, unit); // here the value of unit is accessed from memory
//...
logMessage();
// if logMessage is defined in another cpp file, the compiler
// must assume that it could modify the value of unit
arm.start(value, unit); // here the value of unit must be accessed from memory again,
// the compiler can't reuse the value from the previous access
}
&lt;/code>&lt;/pre>&lt;p>Because it's possible that [throwBall]{.title-ref} could be called like
this sneaky code:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">CLengthUnit unit = /*...*/;
void logMessage() { unit = otherUnit; }
throwBall(10, unit);
&lt;/code>&lt;/pre>&lt;p>When it's passed by value, the parameter is a local variable, so the
compiler can see that it's not modified, and only needs to access the
memory once:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">void throwBall(double value, CLengthUnit unit)
{
hand.hold(ball);
arm.prepareThrow(value, unit); // here the value of unit is accessed from memory
//...
logMessage();
arm.start(value, unit); // here the compiler can just reuse the value from the previous access
}
&lt;/code>&lt;/pre>&lt;p>Return values are a bit different, but I would need to have a &amp;quot;good
reason&amp;quot; to use references anywhere. [CMeasurementUnit]{.title-ref}
contains just a single non-owning pointer to const data, so it easily
fits in a CPU register like any arithmetic type. operator== hasn't been
changed in ages. You might be thinking of [convertFrom]{.title-ref}
which we discussed here: &lt;a href="https://dev.swift-project.org/T207">https://dev.swift-project.org/T207&lt;/a>&lt;/p>
&lt;p>Either way, comparing [m_data == other.m_data]{.title-ref} pointers is
just as good as comparing [this == &amp;amp;other]{.title-ref} pointers.&lt;/p>
&lt;p>Are our normal PQs trivial?&lt;/p>
&lt;p>Mat SutcliffeYesterday at 23:47 Yes, actually. Whether they are
&amp;quot;small&amp;quot; is another question. CPhysicalQuantity contains just a double
and a CMeasurementUnit (which contains a pointer). So it's 128 bits (8
bytes). Could fit in an SSE2 register, so probably &amp;quot;small&amp;quot;. But it's
debatable. And some of our derived PQs add more members, like
magnetic/true for headings, datum for altitudes. Mat SutcliffeYesterday
at 23:56&lt;/p>
&lt;p>Actually IMHO the most important thing in all of this is that the
[CMeasurementUnit::Data]{.title-ref} instances be
[constexpr]{.title-ref} as it means they are initialized at
compile-time, so no static order fiasco.&lt;/p>
&lt;p>And only &amp;quot;literal types&amp;quot; are candidates for [constexpr]{.title-ref},
which is yet another category of type&lt;/p></description></item><item><title>Docs: CLANG \"implicit copy constructor\"</title><link>https://swift-project.github.io/docs/knowhow/programming/clangimplicitcopyctor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/clangimplicitcopyctor/</guid><description>
&lt;p>&lt;code>CLANG warning: definition of implicit copy assignment operator for 'CMeasurementUnit' is deprecated because it has a user-declared destructor&lt;/code>&lt;/p>
&lt;p>Solution:&lt;/p>
&lt;pre>&lt;code class="language-{.diff}" data-lang="{.diff}">//! Destructor
~CMeasurementUnit() = default;
+
+ //! Copy constructor
+ CMeasurementUnit(const CMeasurementUnit &amp;amp;) = default;
+
+ //! Copy assignment operator
+ CMeasurementUnit &amp;amp;operator =(const CMeasurementUnit &amp;amp;) = default;
&lt;/code>&lt;/pre></description></item><item><title>Docs: Compilers' C++ feature support</title><link>https://swift-project.github.io/docs/knowhow/programming/cppfeatures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/cppfeatures/</guid><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>C++14 feature&lt;/th>
&lt;th>VS 2019 16.6; cl.exe 19.26.28806&lt;/th>
&lt;th>Ubuntu 16.04 GCC 5.4&lt;/th>
&lt;th>Ubuntu 18.04 GCC 7.4&lt;/th>
&lt;th>Ubuntu 20.04 GCC 9.3&lt;/th>
&lt;th>Xcode 11.5; Apple clang 11.0.3 (LLVM 9.0.0)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Return type deduction&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Generic lambdas&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Generalized lambda capture&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Variable templates&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Member initializers for aggregates&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Generalized &lt;code>constexpr&lt;/code>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>constexpr&lt;/code> for std lib types&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>std::integer_sequence&lt;/code>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Minor std lib improvements&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>More std lib improvements&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Shorthand alias traits&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Binary literals&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Single quote as digit separator&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>C++17 feature&lt;/th>
&lt;th>VS 2019 16.6; cl.exe 19.26.28806&lt;/th>
&lt;th>Ubuntu 16.04 GCC 5.4&lt;/th>
&lt;th>Ubuntu 18.04 GCC 7.4&lt;/th>
&lt;th>Ubuntu 20.04 GCC 9.3&lt;/th>
&lt;th>Xcode 11.5; Apple clang 11.0.3 (LLVM 9.0.0)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Nested namespace definition&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Fold expressions&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Lambda capture &lt;code>*this&lt;/code>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>constexpr&lt;/code> lambdas&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>½&lt;/td>
&lt;td>½&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Range &lt;code>for&lt;/code> heterogeneous iterators&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>[[fallthrough]]&lt;/code> attribute&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>if constexpr&lt;/code>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>if&lt;/code>-init and &lt;code>switch&lt;/code>-init&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Structured bindings&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Inline variables&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>auto&lt;/code> non-type template parameters&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>✔&lt;/td>
&lt;td>✔&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>See also &lt;a href="http://en.cppreference.com/w/cpp/compiler_support">http://en.cppreference.com/w/cpp/compiler_support&lt;/a>&lt;/p></description></item><item><title>Docs: Crashpad</title><link>https://swift-project.github.io/docs/knowhow/programming/crashpad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/crashpad/</guid><description>
&lt;p>= Introduction =&lt;/p>
&lt;p>Crashpad is a library for capturing, storing and transmitting postmortem
crash reports from a client to an upstream collection server. Crashpad
aims to make it possible for clients to capture process state at the
time of crash with the best possible fidelity and coverage, with the
minimum of fuss.&lt;/p>
&lt;p>Crashpad also provides a facility for clients to capture dumps of
process state on-demand for diagnostic purposes.&lt;/p>
&lt;p>Crashpad additionally provides minimal facilities for clients to adorn
their crashes with application-specific metadata in the form of
per-process key/value pairs. More sophisticated clients are able to
adorn crash reports further through extensibility points that allow the
embedder to augment the crash report with application-specific metadata.&lt;/p>
&lt;p>More information can be found under
[[&lt;a href="https://chromium.googlesource.com/crashpad/crashpad/+/master/doc/overview_design.md">https://chromium.googlesource.com/crashpad/crashpad/+/master/doc/overview_design.md&lt;/a>
| Crashpad Overview Design]]&lt;/p>
&lt;p>= Supported Platforms =&lt;/p>
&lt;p>Currently Crashpad supports Windows and Mac OS only. On Windows, the
supported compiler is MS Visual Studio. MinGW is not supported.&lt;/p>
&lt;p>= &lt;em>swift&lt;/em> Infrastructure =&lt;/p>
&lt;p>== Crash Handler ==&lt;/p>
&lt;p>Crashpad is automatically linked and activated with a release build of
&lt;em>swift&lt;/em>. A standalone executable called
[swift_crashpad_handler]{.title-ref} is monitoring each &lt;em>swift&lt;/em>
executable. [swift_crashpad_handler]{.title-ref} will collect process
information including a full stack trace, in case of a abnormal abort.
The collected information is automatically written into a minidump file
and uploaded to &lt;a href="https://swift-project.sp.backtrace.io">https://swift-project.sp.backtrace.io&lt;/a>&lt;/p>
&lt;p>== &lt;em>swift&lt;/em> Breakpad Server ==&lt;/p>
&lt;p>&lt;em>swift&lt;/em> Breakpad Server is our fork of &amp;quot;Simple Breakpad Server&amp;quot;. This
fork is currently hosted at
&lt;a href="https://github.com/emiro85/simple-breakpad-server">https://github.com/emiro85/simple-breakpad-server&lt;/a> The implementation
is based on nodejs. It accepts minidump crashreports and symbols files
needed to create a readable stack trace. Symbol files are automatically
uploaded from a Jenkins Release build.&lt;/p>
&lt;p>== Produce Stacktrace Manually ==&lt;/p>
&lt;p>In case a crash dump was uploaded without its corresponding symbol files
(e.g. from a non-release Jenkins job), the stack trace can also created
locally. This requires the following:&lt;/p>
&lt;blockquote>
&lt;p># &lt;strong>Symbol files:&lt;/strong> Either download them from the Jenkins job (be
careful since only the latest artifacts are kept. As soon as the job
runs again, the artifacts are lost). Extract it. # Download
executable [minidump_stackwalk]{.title-ref} ## Windows: Link TBD
## Mac OS: Link TBD # Download the dump file from Breakpad Server
if you don't have it locally already&lt;/p>
&lt;/blockquote>
&lt;p>Run the command in a terminal: [minidump_stackwalk &amp;lt;path to dump
file&amp;gt; &amp;lt;path to symbol files&amp;gt; &amp;gt; stacktrace.txt]{.title-ref}&lt;/p></description></item><item><title>Docs: DBus (swift and DBus)</title><link>https://swift-project.github.io/docs/knowhow/programming/dbus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/dbus/</guid><description>
&lt;p>=== Windows libraries for DBus ===&lt;/p>
&lt;p>[[ knowhow/programming/swiftbuild/dbus/ ]]&lt;/p>
&lt;p>=== QDBusViewer ===&lt;/p>
&lt;p>In order to use [QDBusViewer]{.title-ref} the [dbus-1.3.dll]{.title-ref}
needs to be copied to the same folder as [QDBusViewer]{.title-ref}&lt;/p></description></item><item><title>Docs: DEC 2018 C++ review</title><link>https://swift-project.github.io/docs/knowhow/programming/dec2018review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/dec2018review/</guid><description>
&lt;p>== QString ==&lt;/p>
&lt;ul>
&lt;li>Old: [QStringLiteral(&amp;quot;{ &amp;quot;) % foo % QStringLiteral(&amp;quot;
}&amp;quot;)]{.title-ref}&lt;/li>
&lt;li>New: [u&amp;quot;{ &amp;quot; % foo % u&amp;quot; }&amp;quot;]{.title-ref}&lt;/li>
&lt;/ul>
&lt;p>When a string is only a single character you can use a UTF-16 character
literal:&lt;/p>
&lt;ul>
&lt;li>Old: [QStringLiteral(&amp;quot;[&amp;quot;) % foo %
QStringLiteral(&amp;quot;]&amp;quot;)]{.title-ref}&lt;/li>
&lt;li>New: [u'[' % foo % u']']{.title-ref}&lt;/li>
&lt;/ul>
&lt;p>See full detailed info here: [[ knowhow/programming/qt-strings/ ]]&lt;/p>
&lt;p>== Loops ==&lt;/p>
&lt;p>One more performance point: to loop over the values of a
[QHash]{.title-ref} or [QMap]{.title-ref} or [CDictionary]{.title-ref}
there is no need to call [.values()]{.title-ref}, just loop over the
container itself:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">for (const auto &amp;amp;value : map.values()) { ... } // old
for (const auto &amp;amp;value : map) { ... } // new
&lt;/code>&lt;/pre>&lt;p>Calling [.values()]{.title-ref} is just copying them into a
[QList]{.title-ref} for no reason. Furthermore, to loop over the keys,
we have [makeKeysRange]{.title-ref} in `blackmisc/range.h`:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">for (const auto &amp;amp;key : map.keys()) { ... } // old
for (const auto &amp;amp;key : makeKeysRange(map)) { ... } // new
&lt;/code>&lt;/pre>&lt;p>This avoids copying the keys into a [QList]{.title-ref}, as it just
adapts the begin and end iterators. And to loop over keys //and//
values, we have `makePairsRange`:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">for (const auto &amp;amp;key : map.keys()) /*********** old */
{
doSomethingWithKey(key);
doSomethingWithValue(map[key]);
}
for (const auto pair : makePairsRange(map)) /* new */
{
doSomethingWithKey(pair.first);
doSomethingWithValue(pair.second);
}
&lt;/code>&lt;/pre>&lt;p>This avoids copying the keys into a [QList]{.title-ref} //and//
performing a lookup for each one. In C++17 we will be able to unpack the
pair like this:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">for (const auto [key, value] : makePairsRange(map))
{
doSomethingWithKey(key);
doSomethingWithValue(value);
}
&lt;/code>&lt;/pre>&lt;p>I think I have fixed it to use these everywhere possible in our
codebase. Caveat: [makeKeysRange]{.title-ref} and
[makePairsRange]{.title-ref} only work with lvalues. You will get a
compile error if you try to use them with rvalues, because it would be
unsafe.&lt;/p></description></item><item><title>Docs: DirectX and DirectInput</title><link>https://swift-project.github.io/docs/knowhow/programming/dx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/dx/</guid><description>
&lt;p>Good joystick capturing article: &lt;a href="https://bell0bytes.eu/directinput/">https://bell0bytes.eu/directinput/&lt;/a>&lt;/p>
&lt;ul>
&lt;li>[DIDFT_PSHBUTTON]{.title-ref} A push button. A push button is
reported as down when the user presses it, and as up when the user
releases it.&lt;/li>
&lt;li>[DIDFT_TGLBUTTON]{.title-ref} A toggle button. A toggle button is
reported as down when the user presses it and remains so until the
user presses the button a second time.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Doxygen API pages</title><link>https://swift-project.github.io/docs/knowhow/programming/doxygen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/doxygen/</guid><description>
&lt;ul>
&lt;li>swift pilot client (C++): [[
&lt;a href="https://build.swift-project.org/job/swift_pilotclient_doxygen/Doxygen/">https://build.swift-project.org/job/swift_pilotclient_doxygen/Doxygen/&lt;/a>
| Doxygen build ]]&lt;/li>
&lt;li>datastore, the mapping database (LAMP, JavaScript, PHP): [[
&lt;a href="https://build.swift-project.org/job/swift_datastore_doxygen/Doxygen/">https://build.swift-project.org/job/swift_datastore_doxygen/Doxygen/&lt;/a>
| Doxygen build ]]&lt;/li>
&lt;li>[[ help/swiftgeneral/ms/techdetails/ ]]&lt;/li>
&lt;/ul></description></item><item><title>Docs: git tips and tricks</title><link>https://swift-project.github.io/docs/knowhow/programming/git/tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/git/tips/</guid><description>
&lt;p>Git Tips and Tricks&lt;/p>
&lt;p>[git pull --rebase]{.title-ref}&lt;/p>
&lt;p>Suppose you&amp;rsquo;ve made a small change to the code that you want to
[push]{.title-ref} to the remote repository. But before you can do that,
you need to [pull]{.title-ref} some other recent changes that other
people have made, to synchronise your local repo with the remote. Here&amp;rsquo;s
the situation before the &lt;code>pull&lt;/code>:&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">* your commit == local HEAD * their commit 2 == remote HEAD
| |
| * their commit 1
| |
+---------------+---------------+
|
* common ancestor
&lt;/code>&lt;/pre>&lt;p>And here is what the tree would look like after an ordinary `pull`:&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">* merge commit == local HEAD
|
+------------------+
| |
* your commit * their commit 2 == remote HEAD
| |
| * their commit 1
| |
+------------------+
|
* common ancestor
&lt;/code>&lt;/pre>&lt;p>But if you used [pull --rebase]{.title-ref} instead, the tree would
look like this:&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">* your commit == local HEAD
|
* their commit 2 == remote HEAD
|
* their commit 1
|
* common ancestor
&lt;/code>&lt;/pre>&lt;p>This is good for small changes when you want the git history to be nice
and linear, not littered with merges that make it harder to read through
and follow. But it is potentially dangerous for anything bigger because
it changes the parent commit of your commit, which has the effect of
also changing the SHA1 of your commit, an invasive rewriting of history.&lt;/p>
&lt;p>In particular, you must not use [push --rebase]{.title-ref} if you&amp;rsquo;ve
already pushed your local commit to some other branch; that would be bad
because then there would be two different versions of history which
would be hard to reconcile. But if your commit only exists in your one
local branch, then you should be safe to rebase it. It could be said
that it subverts the &amp;ldquo;branch and merge&amp;rdquo; philosophy of git, but OTOH it
is a better semantic model of your intent, and that&amp;rsquo;s why it&amp;rsquo;s provided
as an option. See also
[[&lt;a href="http://stackoverflow.com/questions/2472254/when-should-i-use-git-pull-rebase">http://stackoverflow.com/questions/2472254/when-should-i-use-git-pull-rebase&lt;/a>
| SO question]] .&lt;/p>
&lt;h1 id="committing-individual-hunks-or-lines">Committing individual hunks or lines&lt;/h1>
&lt;p>If you&amp;rsquo;ve made several logically separate changes in the same file, and
you want to put these changes into separate commits so that other
developers can more easily make sense of your changes, git-gui can help:&lt;/p>
&lt;p>{F3630}&lt;/p>
&lt;p>Through the right-click context menu you can choose to commit only
certain hunks or lines, instead of entire files. Do be careful, though,
that the project should be in a buildable state after each individual
commit, so if A depends on B then B should be committed first.&lt;/p>
&lt;p>(A hunk is a block of one or more changes, with a header line at the top
which begins with [@]{.title-ref} [@]{.title-ref}.)&lt;/p>
&lt;h1 id="resolving-conflicts-with-diff3">Resolving conflicts with diff3&lt;/h1>
&lt;p>It can be difficult when resolving conflicts, when you don't know the
context of the other developer's changes. Traditional git diff only
shows your version of the code and the other developer's version of the
code, which can lead to conflicts being resolved wrongly and breaking
the other developer's work. Git has an option to enable the diff3
conflict style, which also shows the version of the code as it was in
the common ancestor of your changes and their changes, which makes it
much easier to see exactly what changed:&lt;/p>
&lt;p>[git config --global merge.conflictstyle diff3]{.title-ref}&lt;/p>
&lt;h1 id="fast-forward-merge-to-another-branch-without-touching-files">Fast-forward merge to another branch without touching files&lt;/h1>
&lt;p>It is a common task when working in a feature branch, to merge your
branch into the integration branch. Traditionally, you
[checkout]{.title-ref} the integration branch, then [merge]{.title-ref}
the feature branch, then [checkout]{.title-ref} the feature branch
again. If it is a fast-forward merge, then all your files will be
exactly as they were before the merge, except their timestamps will have
changed, resulting in your IDE unnecessarily rebuilding the code. There
is a trick to avoid this:&lt;/p>
&lt;p>[git push . feature/T123_foo:develop/0.9.0]{.title-ref}&lt;/p>
&lt;p>[git push .]{.title-ref} means &amp;quot;push to my own local repository&amp;quot; and
[feature/T123_foo:develop/0.9.0]{.title-ref} means &amp;quot;update
[develop/0.9.0]{.title-ref} to point to the HEAD of
[feature/T123_foo]{.title-ref}&amp;quot;. It will fail if the merge is not a
fast-forward, which is good, because we want only fast-forward merges in
integration branches.&lt;/p></description></item><item><title>Docs: git version control and arc</title><link>https://swift-project.github.io/docs/knowhow/programming/git/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/git/git/</guid><description>
&lt;p>::: {.toctree glob=&amp;quot;&amp;quot; hidden=&amp;quot;&amp;quot;}
./*
:::&lt;/p>
&lt;p>Placeholder, see TOC below&lt;/p></description></item><item><title>Docs: Jenkinsfile</title><link>https://swift-project.github.io/docs/knowhow/programming/jenkinsfile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/jenkinsfile/</guid><description>
&lt;p>Scripted Jenkinsfile DSL (domain-specific language) is based on the
&lt;strong>[Apache Groovy](&lt;a href="http://www.groovy-lang.org/documentation.html">http://www.groovy-lang.org/documentation.html&lt;/a>)&lt;/strong>
language.&lt;/p>
&lt;p>Documentation resources:&lt;/p>
&lt;ul>
&lt;li>[Steps
reference](&lt;a href="https://build.swift-project.org/job/swift/pipeline-syntax/html">https://build.swift-project.org/job/swift/pipeline-syntax/html&lt;/a>)
(you need to be logged in to Jenkins)&lt;/li>
&lt;li>[Global
variables](&lt;a href="https://build.swift-project.org/job/swift/pipeline-syntax/globals">https://build.swift-project.org/job/swift/pipeline-syntax/globals&lt;/a>)
(you need to be logged in to Jenkins)&lt;/li>
&lt;li>[Online book](&lt;a href="https://jenkins.io/doc/book/pipeline/">https://jenkins.io/doc/book/pipeline/&lt;/a>) (includes
more complete [steps
reference](&lt;a href="https://jenkins.io/doc/pipeline/steps/">https://jenkins.io/doc/pipeline/steps/&lt;/a>) including
plugins)&lt;/li>
&lt;li>[Jenkins Java API](&lt;a href="https://javadoc.jenkins.io/">https://javadoc.jenkins.io/&lt;/a>) can be used in
Jenkinsfiles&lt;/li>
&lt;/ul></description></item><item><title>Docs: libxplanemp repo - commit changes to libxplanemp</title><link>https://swift-project.github.io/docs/knowhow/programming/git/xpmprepo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/git/xpmprepo/</guid><description>
&lt;p>In general, there are three things to consider:&lt;/p>
&lt;ol>
&lt;li>Don't add any [Ref]{.title-ref} in git comments. libxplanemp is
shared by other projects where it would not make sense.&lt;/li>
&lt;li>Style guide: in &lt;em>swift&lt;/em> we indent by 4 spaces, but libxplanemp uses
tabs. Comply to avoid huge white space changes and unreadable diffs.&lt;/li>
&lt;li>Our {icon code} repository is just a read-only monitor of
[https://github.com/swift-project/libxplanemp]{.title-ref}. Changes
must be pushed here.&lt;/li>
&lt;/ol></description></item><item><title>Docs: Prepar3D SimConnect Libraries</title><link>https://swift-project.github.io/docs/knowhow/programming/p3dsimconnect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/p3dsimconnect/</guid><description>
&lt;p>== Introduction ==&lt;/p>
&lt;p>Prepar3D in contrast to Microsoft, ships SimConnect only as static
libraries. This has several problems: * It requires two different
libraries for Release and Debug builds * One has to know exactly what
other dependencies are necessary during linking * It is not possible to
load and resolve the libraries at runtime * ...&lt;/p>
&lt;p>In order to avoid the problems above, the static libraries can be linked
to shared libraries by some manual preparation and invoking MSVC
compiler at command line.&lt;/p>
&lt;p>WARNING: I have not found a way to create a simple project (neither
qmake nor Visual Studio Project) to perform the linking. So the linker
has to be called manually in a cmd.&lt;/p>
&lt;p>== Directories ==&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>client\externals\common\include\simconnect\P3D-v4&lt;/code> header file&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>The header file is generated by us (swift) and version
dependent.&lt;/li>
&lt;li>The original headers are in the sub directories.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;code>client\externals\win32-msvc\64\lib&lt;/code> here we keep the generated dlls
like &lt;code>SimConnect.P3D-v4.3.dll&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>== Header file ==&lt;/p>
&lt;p>The header file is a &lt;em>swift&lt;/em> specific version. We keep the old header
files so we can also find them if needed. For informational purposes we
keep a list of files containing the &lt;code>diffs&lt;/code>.&lt;/p>
&lt;p>Steps: - Copy new P3D files to the respective sub-directory - Find out
about the differences: [diff.exe -u 430/SimConnect.h 440/SimConnect.h &amp;gt;
SimConnect430_440.txt]{.title-ref} - Update the &lt;em>swift&lt;/em> version
[SimConnect.h]{.title-ref}&lt;/p>
&lt;p>== Link static library into shared library ==&lt;/p>
&lt;p>In order to link the SimConnect static libraries into a shared one, we
need two inputs:&lt;/p>
&lt;ol>
&lt;li>The shared library itself. The release version is enough - we don't
need to convert the debug library since the API is pure C&lt;/li>
&lt;li>The list of symbols to export from the shared library. Those are
defined in a module definition file (.def).&lt;/li>
&lt;/ol>
&lt;p>=== Dump SimConnect API Symbols ===&lt;/p>
&lt;p>Regarding point 2, we are interested only in the SimConnect API
functions. They usually start with [SimConnect_]{.title-ref}. Use the
following command to build a list of SimConnect API functions that are
implemented in the static library:&lt;/p>
&lt;p>[dumpbin /LINKERMEMBER:1 SimConnect.lib | findstr SimConnect_ &amp;gt;
symbols.dat]{.title-ref}&lt;/p>
&lt;p>The resulting [symbols.dat]{.title-ref} file will look similar to this:&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">6CBA2 SimConnect_AICreateEnrouteATCAircraft
6CBA2 SimConnect_AICreateNonATCAircraft
6CBA2 SimConnect_AICreateObjectWithExternalSim
6CBA2 SimConnect_AICreateParkedATCAircraft
&lt;/code>&lt;/pre>&lt;p>From this symbol list, we can now create our module definition file
`SimConnect.def`:&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">LIBRARY SimConnect.P3D-v4.0.dll
EXPORTS
SimConnect_AICreateEnrouteATCAircraft
SimConnect_AICreateNonATCAircraft
SimConnect_AICreateObjectWithExternalSim
SimConnect_AICreateParkedATCAircraft
&lt;/code>&lt;/pre>&lt;p>=== Link shared library ===&lt;/p>
&lt;p>Finally, we can run our linker command. It requires several input like
the machine type, several other dependent Windows libraries, our created
SimConnect.def and an output filename that should be equal to the
[LIBRARY]{.title-ref} name specified in [SimConnect.def]{.title-ref}.&lt;/p>
&lt;p>If you are running the command from a MSVC command prompt, you won't
have the necessary Windows SDK library path configured. To do this, you
need to add the required path manually to the %LIB% environment
variable. It is fine to use the latest Windows 10 SDK. In my case that
was:&lt;/p>
&lt;p>[set LIB=%LIB%C:Program Files (x86)Windows
Kits10Lib10.0.16299.0umx64;C:Program Files (x86)Windows
Kits10Lib10.0.16299.0ucrtx64;]{.title-ref}&lt;/p>
&lt;p>Finally run the linker command: [cl.exe SimConnect.lib User32.lib
Advapi32.lib Ole32.lib Shell32.lib /link /DLL /MACHINE:X64
/def:SimConnect.def /out:SimConnect.P3D-v4.0.dll]{.title-ref}&lt;/p></description></item><item><title>Docs: Qt Strings (QString)</title><link>https://swift-project.github.io/docs/knowhow/programming/qt-strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/qt-strings/</guid><description>
&lt;p>== Qt Strings Overview ==&lt;/p>
&lt;p>The best way to know which code construct to use in a given situation is
to understand the API of the facilities you use, and what they provide.&lt;/p>
&lt;p>===== String producers =====&lt;/p>
&lt;ul>
&lt;li>
&lt;p>!!*&lt;em>`QString`&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>`QString` is a class that owns a shared,
dynamically-allocated UTF-16 string.&lt;/strong> The sharing is detached
(so the string data is copied) when any non-const operation is
performed (copy-on-write). When constructing a
[QString]{.title-ref} from a string literal, the data is
always copied.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>!!*&lt;em>`QStringLiteral`&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>`QStringLiteral` is a macro that &amp;quot;returns&amp;quot; a
`QString`.&lt;/strong> The internal shared data of the
[QString]{.title-ref} is prepared at compile-time, not
dynamically allocated, and not copied. If you have a string
literal, and you need a [QString]{.title-ref}, then
[QStringLiteral]{.title-ref} is what you want. But you don't
always need a [QString]{.title-ref}. In situations where you
//don't// need a [QString]{.title-ref}, it is a waste of time
to use [QStringLiteral]{.title-ref}.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>!!*&lt;em>`QLatin1String`&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>`QLatin1String` is a class that holds a `const char*`
pointing to a string literal.&lt;/strong> Its use cases are limited, as
converting it to a [QString]{.title-ref} involves converting
the Latin-1 data into UTF-16. Certain Qt functions are
overloaded for [QLatin1String]{.title-ref} because they can
directly use the Latin-1 data without converting it to UTF-16.
For example, JSON keys can be passed as
[QLatin1String]{.title-ref}. In such cases, using a
[QString]{.title-ref} would perform an unnecessary allocation
and convertion from Latin-1 to UTF-16 and back again.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>!!*&lt;em>`QStringView`&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>`QStringView` is a class that holds a `const
char16_t*` pointing to some UTF-16 string.&lt;/strong> It is often
useful as a function parameter type. If you write a function
that takes a string parameter, which it uses and then
discards, it can be beneficial to declare the parameter as
[QStringView]{.title-ref}. The caller can then choose to pass
a string to your function using whatever type is most
convenient to them. If they had a [char16_t*]{.title-ref}
then they would not be forced to construct an unnecessary
[QString]{.title-ref} just to be able to pass it to your
function.&lt;/li>
&lt;li>If your function really does need a [QString]{.title-ref},
don't use [QStringView]{.title-ref} as it would inhibit the
implicit sharing feature of [QString]{.title-ref}.&lt;/li>
&lt;li>Because [QStringView]{.title-ref} is such a simple class, it
is more efficient to pass it by value, not reference.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>!!*&lt;em>`QStringRef`&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>`QStringRef` is a class that references a substring of an
existing `QString` without copying it.&lt;/strong> This can be useful
when working with substrings, where you would otherwise be
allocating unnecessary temporary [QString]{.title-ref}
instances to copy substrings into them. For example,
[s.leftRef(3).trimmed()]{.title-ref} instead of
[s.left(3).trimmed()]{.title-ref}.&lt;/li>
&lt;li>Of particular note is [QString::splitRef]{.title-ref}, which
is like [split]{.title-ref} except that it returns a
[QVector&amp;lt;QStringRef&amp;gt;]{.title-ref} instead of a
[QStringList]{.title-ref}. Using [QStringList]{.title-ref}
would be very inefficient if you just want to loop over the
parts, as it would reallocate and copy every single one for no
reason.&lt;/li>
&lt;li>Just make sure that the [QStringRef]{.title-ref} gets
destroyed //before// its referenced [QString]{.title-ref},
otherwise this would be a dangling reference.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>!!*&lt;em>`QChar`&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>`QChar` is a class that contains a single UTF-16
character.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>!!*&lt;em>`QLatin1Char`&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>`QLatin1Char` is a class that contains a single Latin-1
character.&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>===== String consumers =====&lt;/p>
&lt;ul>
&lt;li>
&lt;p>!!*&lt;em>QString::arg&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>`arg` is a member function of QString,&lt;/strong> so obviously if
you want to call [arg]{.title-ref} then you need a
[QString]{.title-ref} to call it on. So if you want to call
[arg]{.title-ref} on a string literal, then you almost always
want [QStringLiteral]{.title-ref}. The same goes for other
member functions of [QString]{.title-ref}. But note that
[QStringView]{.title-ref} and [QStringRef]{.title-ref} provide
many of the same methods.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>!!*&lt;em>operator %&lt;/em>*!!&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>The % operator provides more efficient string
concatenation&lt;/strong> when [&amp;lt;QStringBuilder&amp;gt;]{.title-ref} is
included. Instead of using lots of temporary
[QString]{.title-ref} objects to store each subexpression
(like [+]{.title-ref} does) it collects the parts together and
concatenates them all in one go.&lt;/li>
&lt;li>You should look in the [qstringbuilder.h]{.title-ref} header
to see which types can be concatenated. The class template
[QConcatenable]{.title-ref} is specialised on each
concatenable type: [QString]{.title-ref},
[QStringRef]{.title-ref}, [QStringView]{.title-ref},
[char16_t*]{.title-ref}, etc. So for string literals, these
can be concatenated directly as UTF-16 literals, without any
[QString]{.title-ref}-based intermediary.&lt;/li>
&lt;li>One rare exception to the above rule: if every type in a given
concatenation is a fundamental type like [char*]{.title-ref}
or [char16_t*]{.title-ref}, it will fail to compile. This is
because operators can obviously not be overloaded on built-in
types. At least one of the parts of the concatenation must be
a class type. The best workaround is [QStringView]{.title-ref}
as it is the most lightweight.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>== TL;DR ==&lt;/p>
&lt;p>It can take time and experience to cement the understanding in the brain
so that it becomes intuitive (to become &amp;quot;fluent&amp;quot;). Therefore when
working with string literals you can use the following cheat sheet that
should cover most situations:&lt;/p>
&lt;hr>
&lt;pre>&lt;code> Empty string Single character Multiple characters
&lt;/code>&lt;/pre>
&lt;hr>
&lt;p>Store in a QString QString() QStringLiteral QStringLiteral&lt;/p>
&lt;p>Concatenate with % u'' u&amp;quot;&amp;quot;&lt;/p>
&lt;p>As QLatin1String QLatin1String QLatin1String QLatin1String
param&lt;/p>
&lt;h2 id="as-qstringview-param--u-----------u------------u">As QStringView param u&amp;quot;&amp;quot; u&amp;quot;&amp;quot; u&amp;quot;&amp;quot;&lt;/h2></description></item><item><title>Docs: Rebasing and conflicts</title><link>https://swift-project.github.io/docs/knowhow/programming/git/rebase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/git/rebase/</guid><description>
&lt;p>From
[[&lt;a href="https://dev.vatsim-germany.org/boards/22/topics/2236?r=2251#message-2251">https://dev.vatsim-germany.org/boards/22/topics/2236?r=2251#message-2251&lt;/a>
| Redmine]]&lt;/p>
&lt;p>As a result of working through the branch in the live session yesterday
I think I got a bit closer to understanding the reasons for the conflict
issues which have occurred with Klaus' previous two branches, so I think
I can try to offer some lessons learned, in the form of a kind of
standard model for doing rebasing.&lt;/p>
&lt;p>### The branch&lt;/p>
&lt;ul>
&lt;li>The purpose of pushing branches is so that changes can be reviewed
before being merged. Therefore, a branch has done its job well if it
is easy to review, and a branch that is easier to review can be
merged sooner.&lt;/li>
&lt;li>The more changes are in a branch, the more potential there is for
conflicts, so avoid making a branch any bigger than it needs to be.&lt;/li>
&lt;/ul>
&lt;p>### The first version&lt;/p>
&lt;ul>
&lt;li>Throughout the process of making changes in a branch, keep one eye
on the git log which you are creating, and try to see it from the
point of view of a reviewer. With each change that you make, ask
yourself &amp;ldquo;am I changing something which I already changed in an
earlier commit in the same branch?&amp;rdquo; If yes, then it is very likely
to make sense for it to be fixed-up onto that earlier commit,
instead of making a separate commit for something which is just a
continuation of it. This will mean that the reviewer doesn&amp;rsquo;t waste
time reviewing several different versions of your code. A reviewer
must review &lt;em>changes&lt;/em>, but he really only cares about the &lt;em>final
state&lt;/em> of your code, not the intermediate states.&lt;/li>
&lt;li>Applying this model continuously at every step of the coding process
is much easier than trying to do the fixing-up all at the very end.&lt;/li>
&lt;li>Use the [fixup! message]{.title-ref} to create a commit which should
fix-up an earlier commit of the same branch, to utilize the
&amp;ldquo;autosquash&amp;rdquo; facility of [git rebase -i]{.title-ref}. There is no
need to change the message of the earlier commit if it still makes
sense.&lt;/li>
&lt;/ul>
&lt;p>### Rebasing on the latest master&lt;/p>
&lt;ul>
&lt;li>It can commonly take up to a couple of weeks (sometimes longer) to
finish the first version of a branch. In that time, it is likely
that [master]{.title-ref} will have changed, so that the base of
your branch is out-of-date. Another use of [git rebase]{.title-ref}
(without the [-i]{.title-ref}) is to bring the base of a branch
up-to-date with the latest [master]{.title-ref}. This will need to
be done before the merge anyway, so it makes sense to do it before
the review, so that any resulting problems can be caught by the
review.&lt;/li>
&lt;li>After rebasing onto the latest [master]{.title-ref}, if you find
that you need to make some changes to resolve some issues arising
from conflicts, then those changes should be fix-ups onto the
commits in your branch which triggered the conflicts. This will
avoid triggering the same conflicts again if you need to rebase onto
the latest [master]{.title-ref} again.&lt;/li>
&lt;li>As described above, [git rebase -i]{.title-ref} and [git
rebase]{.title-ref} (without the [-i]{.title-ref}) are used for two
different purposes. You shouldn&amp;rsquo;t try to do both in a single step.
Always do [git rebase -i]{.title-ref} to apply any @fixup! message&lt;/li>
&lt;/ul></description></item><item><title>Docs: Relevant known Qt bugs</title><link>https://swift-project.github.io/docs/knowhow/programming/qtbugs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/qtbugs/</guid><description>
&lt;p>&amp;lt;table&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th&amp;gt;ID&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Type&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;Description&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Status&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Fix Target&amp;lt;/th&amp;gt;
&amp;lt;th&amp;gt;Severity&amp;lt;/th&amp;gt; &amp;lt;th&amp;gt;Comments&amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;[QTBUG-49870](&lt;a href="https://bugreports.qt.io/browse/QTBUG-49870">https://bugreports.qt.io/browse/QTBUG-49870&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Bug&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;On Windows, any application using QtDBus will
hang when exiting&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Fixed&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;5.6&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;high&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;[I596358eb](&lt;a href="https://codereview.qt-project.org/#/c/168405/">https://codereview.qt-project.org/#/c/168405/&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Bug&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Unintended implicit conversion from
[QLatin1String]{.title-ref} to [QString]{.title-ref} in
[QJsonObject]{.title-ref}&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Fixed&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;5.7.1&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;high&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;For JSON performance&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;[QTBUG-57696](&lt;a href="https://bugreports.qt.io/browse/QTBUG-57696">https://bugreports.qt.io/browse/QTBUG-57696&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Bug&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Build with Clang on Windows is broken (Qt
5.7.1)&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Reported&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;5.8.1&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;low&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;[Workaround](&lt;a href="https://codereview.qt-project.org/#/c/180240/">https://codereview.qt-project.org/#/c/180240/&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;[QTBUG-57695](&lt;a href="https://bugreports.qt.io/browse/QTBUG-57695">https://bugreports.qt.io/browse/QTBUG-57695&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Bug&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Visual Studio IDE only: [moc]{.title-ref} always
regenerates all files even if nothing changed (Qt 5.8.0)&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Fixed&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;5.8.0&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;low&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;[Workaround](&lt;a href="https://bugreports.qt.io/browse/QTBUG-57695">https://bugreports.qt.io/browse/QTBUG-57695&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Feature&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;[QJsonObject::insert]{.title-ref} and [operator[]]{.title-ref}
not optimized for [QLatin1String]{.title-ref}&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Reported&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;{icon question}&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;high&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;For JSON performance&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;[QTBUG-53031](&lt;a href="https://bugreports.qt.io/browse/QTBUG-53031">https://bugreports.qt.io/browse/QTBUG-53031&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Bug&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Windows application deadlocks on exit when
unloading a library connected to DBus&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Fixed&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;5.8.1&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;low&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Fixed in 5.6 but regressed
again in 5.8.0&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;[QTBUG-51543](&lt;a href="https://bugreports.qt.io/browse/QTBUG-51543">https://bugreports.qt.io/browse/QTBUG-51543&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Bug&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;[QNetworkAccessManager]{.title-ref} spuriously
becomes [NotAccessible]{.title-ref} on Windows, app must be
restarted&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Fixed {icon question}&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;5.8.1&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;high&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Fix awaiting confirmation&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;[QTBUG-75361](&lt;a href="https://bugreports.qt.io/browse/QTBUG-75361">https://bugreports.qt.io/browse/QTBUG-75361&lt;/a>)&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Bug&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;Stylesheets not applied to all widgets&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Open&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;5.12.4, 5.13&amp;lt;/td&amp;gt; &amp;lt;td&amp;gt;high&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt;&lt;/p></description></item><item><title>Docs: swift JSON formats</title><link>https://swift-project.github.io/docs/knowhow/programming/swiftjsonformats/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/knowhow/programming/swiftjsonformats/</guid><description>
&lt;h1 id="cflightplan-directly">&lt;code>CFlightPlan&lt;/code> directly&lt;/h1>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">{
&amp;quot;aircraftIcao&amp;quot;: {
&amp;quot;combinedType&amp;quot;: &amp;quot;L2J&amp;quot;,
&amp;quot;dbKey&amp;quot;: 5631,
&amp;quot;designator&amp;quot;: &amp;quot;F22&amp;quot;,
...
},
&amp;quot;route&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;takeoffTimeActual&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;takeoffTimePlanned&amp;quot;: &amp;quot;Di Nov 13 23:47:00 2018 GMT&amp;quot;,
&amp;quot;timestampMSecsSinceEpoch&amp;quot;: -1
}
&lt;/code>&lt;/pre>&lt;h1 id="cvarianttitle-ref-format">[CVariant]{.title-ref} format&lt;/h1>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">{
&amp;quot;type&amp;quot;: &amp;quot;BlackMisc::Aviation::CFlightPlan&amp;quot;,
&amp;quot;value&amp;quot;: {
&amp;quot;aircraftIcao&amp;quot;: {
&amp;quot;combinedType&amp;quot;: &amp;quot;L2J&amp;quot;,
&amp;quot;voiceCapabilities&amp;quot;: {
&amp;quot;voiceCapabilities&amp;quot;: 2
}
},
&amp;quot;route&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;takeoffTimeActual&amp;quot;: &amp;quot;&amp;quot;,
&amp;quot;takeoffTimePlanned&amp;quot;: &amp;quot;Mo Nov 12 23:47:00 2018 GMT&amp;quot;,
&amp;quot;timestampMSecsSinceEpoch&amp;quot;: -1
}
}
&lt;/code>&lt;/pre>&lt;h1 id="cache-format">Cache format&lt;/h1>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">{
&amp;quot;lastserver&amp;quot;: {
&amp;quot;type&amp;quot;: &amp;quot;BlackMisc::Network::CServer&amp;quot;,
&amp;quot;value&amp;quot;: {
&amp;quot;address&amp;quot;: &amp;quot;fsd.swift-project.org&amp;quot;,
&amp;quot;description&amp;quot;: &amp;quot;Client project testserver&amp;quot;,
...
}
}
}
&lt;/code>&lt;/pre>&lt;p>=== Container format ===&lt;/p>
&lt;p>tbw.&lt;/p></description></item></channel></rss>