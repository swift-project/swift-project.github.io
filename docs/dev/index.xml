<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>swift project – Developer documentation</title><link>https://swift-project.github.io/docs/dev/</link><description>Recent content in Developer documentation on swift project</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://swift-project.github.io/docs/dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Docs: Build configuration</title><link>https://swift-project.github.io/docs/dev/build-config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/build-config/</guid><description>
&lt;p>&lt;em>swift&lt;/em> uses &lt;a href="http://doc.qt.io/qt-5/qmake-manual.html">qmake&lt;/a> as its
build system. The build can be configured with JSON files, and the qmake
files can interrogate the configuration with custom qmake functions. C++
code can interrogate its configuration using
&lt;code>BlackConfig::CBuildConfig&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Vanilla build&lt;/strong>&lt;/p>
&lt;p>By default, the build will parse a JSON file named &lt;code>default.json&lt;/code> in the
root of the source tree. This file can be edited, but for changing your
local build configuration we recommend creating a new JSON file and
adding its filename to the &lt;code>SWIFT_CONFIG_JSON&lt;/code> variable on your qmake
command line. This avoids git conflicts in &lt;code>default.json&lt;/code>, as you can
add your own JSON file to your &lt;code>.gitignore&lt;/code>.&lt;/p>
&lt;p>&lt;strong>Command line variables&lt;/strong>&lt;/p>
&lt;p>The following variables can be set on the command line when invoking
&lt;code>qmake&lt;/code> and have meaning when building swift:&lt;/p>
&lt;hr>
&lt;p>&lt;code>&amp;quot;SWIFT_CONFIG_JSON+=filename.json&amp;quot;&lt;/code> Loads an additional JSON file into the configuration. The file must be in the root directory of the source tree. The path is relative to the source tree root, and the filename may not contain any special characters. Files are loaded in the order in which they are added to the variable, and &lt;code>default.json&lt;/code> is loaded first. If a JSON file contains a key that was already set in a previously loaded JSON file, the value is overwritten with the last one to be loaded.
&lt;code>&amp;quot;CONFIG+=swiftNoDefaultJson&amp;quot;&lt;/code> By default, &lt;code>default.json&lt;/code> is loaded before any JSON files specified in the &lt;code>SWIFT_CONFIG_JSON&lt;/code> variable. Adding this option prevents this behaviour. This should not really be needed, as each loaded JSON file can overwrite values from a previously loaded one, but the option is provided for completeness.
&lt;code>&amp;quot;CONFIG+=swiftNoCacheConfig&amp;quot;&lt;/code> By default, JSON files are parsed only when processing the root &lt;code>SUBDIRS&lt;/code> project, and saved in the cache, and the sub-projects use the cached values. This option disables this behaviour, so JSON files are reparsed for each sub-project.
&lt;code>&amp;quot;SWIFT_CONFIG.key=value&amp;quot;&lt;/code> Specifies a configuration value as if it had been loaded from a JSON file after all other JSON files have been loaded. For example, &lt;code>&amp;quot;SWIFT_CONFIG.sims.xplane=false&amp;quot;&lt;/code> to disable X-Plane support regardless what is set in any JSON file.&lt;/p>
&lt;hr>
&lt;h2 id="accessing-the-configuration-when-writing-qmake-files">Accessing the configuration when writing &lt;code>qmake&lt;/code> files&lt;/h2>
&lt;p>There is a custom function &lt;code>swiftConfig&lt;/code> for inspecting the values
loaded from JSON within our qmake project files. It is provided both as
a test function and a replace function.&lt;/p>
&lt;h3 id="swiftconfig-test-function">&lt;code>swiftConfig&lt;/code> test function&lt;/h3>
&lt;p>Create a scope with the &lt;code>swiftConfig&lt;/code> function to conditionally evaluate
some qmake directives if and only if a specified key is set to true in
the JSON configuration. The function returns false if the key has any
other value, of if the key is not present.&lt;/p>
&lt;p>&lt;strong>example&lt;/strong>:&lt;/p>
&lt;pre>&lt;code>swiftConfig(sims.p3d) {
# directives to evaluate only if P3D is enabled
}
&lt;/code>&lt;/pre>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">Note&lt;/h4>
For technical reasons, the JSON string value &lt;code>&amp;quot;true&amp;quot;&lt;/code> is treated the
same as the boolean value &lt;code>true&lt;/code>. This is because in qmake,
everything is a string.
&lt;/div>
&lt;h3 id="swiftconfig-replace-function">&lt;code>swiftConfig&lt;/code> replace function&lt;/h3>
&lt;p>Use the &lt;code>swiftConfig&lt;/code> replace function with the &lt;code>$$&lt;/code> sigil to retrieve
the value of a specified key from the JSON.&lt;/p>
&lt;p>&lt;strong>example&lt;/strong>:&lt;/p>
&lt;pre>&lt;code>DEFINES += &amp;quot;BLACK_EOL=$$swiftConfig(endOfLife)&amp;quot;
&lt;/code>&lt;/pre>
&lt;h2 id="modifying-the-configuration-when-writing-qmake-files">Modifying the configuration when writing &lt;code>qmake&lt;/code> files&lt;/h2>
&lt;p>Sometimes in a qmake file you want to override the setting of the JSON
file for some reason. Some test functions are provided for this purpose.&lt;/p>
&lt;h3 id="setswiftconfig-test-function">&lt;code>setSwiftConfig&lt;/code> test function&lt;/h3>
&lt;p>Use this to set the value of a specified key.&lt;/p>
&lt;p>&lt;strong>example&lt;/strong>:&lt;/p>
&lt;pre>&lt;code>setSwiftConfig(endOfLife, 19970829)
&lt;/code>&lt;/pre>
&lt;h3 id="enableswiftconfig-test-function">&lt;code>enableSwiftConfig&lt;/code> test function&lt;/h3>
&lt;p>This is a convenience to set the value of some key(s) to &lt;code>true&lt;/code>.&lt;/p>
&lt;p>&lt;strong>example&lt;/strong>:&lt;/p>
&lt;pre>&lt;code># enable all Microsoft-based simulators
enableSwiftConfig(sims.fs9, sims.fsx, sims.p3d)
&lt;/code>&lt;/pre>
&lt;h3 id="disableswiftconfig-test-function">&lt;code>disableSwiftConfig&lt;/code> test function&lt;/h3>
&lt;p>The reverse of &lt;code>enableSwiftConfig&lt;/code>, this sets the value of some key(s)
to &lt;code>false&lt;/code>.&lt;/p></description></item><item><title>Docs: Caches</title><link>https://swift-project.github.io/docs/dev/cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/cache/</guid><description>
&lt;p>A value cache is a map of &lt;code>QString&lt;/code> keys to &lt;code>CVariant&lt;/code> values, stored
within an entity class which provides distributed access to modify
values and to be notified by a signal when a value is modified. Access
is provided to &lt;code>QObject&lt;/code>-derived classes through a member of type
&lt;code>CCached&amp;lt;T&amp;gt;&lt;/code>, where &lt;code>T&lt;/code> is the expected value type of the specific value
of interest. &lt;code>CCached&amp;lt;T&amp;gt;&lt;/code> automatically converts the &lt;code>CVariant&lt;/code> to and
from the target type &lt;code>T&lt;/code>. The &lt;code>CValueCache&lt;/code> itself, being just a map of
key strings and values, has no contextual awareness of the semantic
meaning of any of the values it contains. That awareness is located at
the level of the &lt;code>CCached&amp;lt;T&amp;gt;&lt;/code>. Through the constructor of &lt;code>CCached&amp;lt;T&amp;gt;&lt;/code>,
an owning class can provide validation routines, default values, and a
slot to be called when the value changes. Validation occurs when an
object changes a value via a member &lt;code>CCached&amp;lt;T&amp;gt;&lt;/code>, and a second,
redundant validation occurs when any other object accesses the changed
value via its own &lt;code>CCached&amp;lt;T&amp;gt;&lt;/code>.&lt;/p>
&lt;h1 id="theory-of-operation">Theory of operation&lt;/h1>
&lt;h2 id="distributed-values">Distributed values&lt;/h2>
&lt;p>There are two layers of distribution in the value cache system. Both
layers of distribution are structurally very similar. In the first
layer, values can be distributed among objects in the same process but
potentially in different threads. This mode of distribution relies on
the regular Qt signal/slot system. In the second layer, values can be
distributed among objects in different processes. This mode of
distribution relies on the Qt signal/slot system and an
interprocess-communication (IPC) mechanism, such as DBus. The particular
IPC mechanism used is decoupled from the value cache system.&lt;/p>
&lt;h2 id="same-process-distribution">Same-process distribution&lt;/h2>
&lt;p>Internally, the &lt;code>CCached&amp;lt;T&amp;gt;&lt;/code> will create a &lt;code>CCachePage&lt;/code> as a child
object of its owner. If an object owns multiple &lt;code>CCached&amp;lt;T&amp;gt;&lt;/code> objects,
then they will all share the same &lt;code>CCachePage&lt;/code>, which acts as the
unified point of access for that owning object. The multitude of
&lt;code>CCachePage&lt;/code> instances in the process communicate with the &lt;code>CValueCache&lt;/code>
through signals and slots. The signal &lt;code>CValueCache::valuesChanged&lt;/code> is
connected to the slot &lt;code>CCachePage::changeValuesFromCache&lt;/code>, and the
signal &lt;code>CCachePage::valuesWantToCache&lt;/code> is connected to the slot
&lt;code>CValueCache::changeValues&lt;/code>. The connection mode is
&lt;code>Qt::AutoConnection&lt;/code>, so the signals will be queued in the event loops
of the appropriate threads. Signals are always queued in the same order
in every thread, so all the &lt;code>CCachePage&lt;/code> instances will observe value
changes occurring in the same order, and this will guarantee that they
maintain consistency with each other.&lt;/p>
&lt;p>&lt;img src="http://img.swift-project.org/cacheseq.png" alt="image">&lt;/p>
&lt;h2 id="inter-process-distribution">Inter-process distribution&lt;/h2>
&lt;p>The structure of connections between &lt;code>CValueCache&lt;/code> instances distributed
in different processes is essentially the same as the structure of
connections between &lt;code>CValuePage&lt;/code> instances in different threads within
the same process, but at a larger scale. One process acts as central
router, and again, the fact that signals are always received in the same
order they were emitted ensures that all processes see a consistent
state. This reusable design pattern is explored in more detail at
&lt;code>relayevent&lt;/code>{.interpreted-text role=&amp;ldquo;ref&amp;rdquo;} :.&lt;/p>
&lt;p>&lt;img src="http://img.swift-project.org/cache.png" alt="image">&lt;/p>
&lt;h1 id="specific-caches">Specific caches&lt;/h1>
&lt;h2 id="settings">Settings&lt;/h2>
&lt;p>Settings are implemented on top of the value cache system. The &lt;code>CSettingsCache&lt;/code> singleton inherits from &lt;code>CValueCache&lt;/code>. The &lt;code>CSetting&amp;lt;Trait&amp;gt;&lt;/code> template extends &lt;code>CCached&amp;lt;T&amp;gt;&lt;/code> with support for validators and default values encapsulated in a trait class alongside the key string.&lt;/p>
&lt;p>Each trait represents a specific value in the settings. As a minimum, the trait class must have a member typedef &lt;code>type&lt;/code> which is the value type of the cached value, and a static method &lt;code>key()&lt;/code> which returns the key string of the cached value. The &lt;code>CSettingTrait&lt;/code> base class simplifies the task of writing new traits.&lt;/p>
&lt;h1 id="batched-changes">Batched changes&lt;/h1>
&lt;p>If a class changes multiple settings at the same time, it is desirable
that only one signal be emitted which covers all the changes, instead of
emitting a separate signal for each individual setting. This is achieved
using &amp;quot;batched&amp;quot; changes:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">auto&lt;/span> &lt;span style="color:#000">batch&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">CSettingsCache&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">instance&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#000">batchChanges&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// RAII object
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">m_fooSetting&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">set&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1234&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;span style="color:#000">m_barSetting&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">set&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">5678&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span>
&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#8f5902;font-style:italic">// RAII object destroyed here, its destructor causes the changes to m_fooSetting and m_barSetting to be committed.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="reacting-to-validation-failures">Reacting to validation failures&lt;/h2>
&lt;p>In the above example, if &lt;code>5678&lt;/code> was invalid for &lt;code>m_barSetting&lt;/code>, the
change to &lt;code>m_fooSetting&lt;/code> would nevertheless be committed anyway. In
order for the validation failure to discard the whole batch, we use
exceptions:&lt;/p>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#204a87;font-weight:bold">try&lt;/span>
&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">auto&lt;/span> &lt;span style="color:#000">batch&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">=&lt;/span> &lt;span style="color:#000">CSettingsCache&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">instance&lt;/span>&lt;span style="color:#000;font-weight:bold">()&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">-&amp;gt;&lt;/span>&lt;span style="color:#000">batchChanges&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">this&lt;/span>&lt;span style="color:#000;font-weight:bold">);&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// RAII object
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">m_fooSetting&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">set&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">1234&lt;/span>&lt;span style="color:#000;font-weight:bold">).&lt;/span>&lt;span style="color:#000">maybeThrow&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// set() returns CStatusMessage...
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">m_barSetting&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">set&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#0000cf;font-weight:bold">5678&lt;/span>&lt;span style="color:#000;font-weight:bold">).&lt;/span>&lt;span style="color:#000">maybeThrow&lt;/span>&lt;span style="color:#000;font-weight:bold">();&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// ...maybeThrow() throws an exception if the message is not empty.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#204a87;font-weight:bold">catch&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#204a87;font-weight:bold">const&lt;/span> &lt;span style="color:#000">CStatusException&lt;/span> &lt;span style="color:#ce5c00;font-weight:bold">&amp;amp;&lt;/span>&lt;span style="color:#000">ex&lt;/span>&lt;span style="color:#000;font-weight:bold">)&lt;/span>
&lt;span style="color:#000;font-weight:bold">{&lt;/span>
&lt;span style="color:#8f5902;font-style:italic">// RAII object destroyed here and batch is abandoned.
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// Display dialog box with ex.status().message()
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">}&lt;/span>
&lt;span style="color:#8f5902;font-style:italic">// RAII object destroyed here and batch is committed if exception was not thrown.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Docs: Design and use of value classes</title><link>https://swift-project.github.io/docs/dev/values/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/values/</guid><description>
&lt;h1 id="the-canonical-value-class">The canonical value class&lt;/h1>
&lt;p>Our value classes all follow a similar pattern of common methods:&lt;/p>
&lt;ul>
&lt;li>A &lt;code>registerMetadata&lt;/code> method to register the class with the metatype
system.&lt;/li>
&lt;li>Stringification methods to generate a string representation of an
object.&lt;/li>
&lt;li>Comparison operators for comparing two objects of the same class.&lt;/li>
&lt;li>An overload of &lt;code>qHash&lt;/code> to generate a hash of an object.&lt;/li>
&lt;li>Methods to marshal and unmarshal an object as a DBus argument.&lt;/li>
&lt;li>Methods to serialize to and from a JSON structure.&lt;/li>
&lt;li>A method to get the icon representing the object.&lt;/li>
&lt;li>Methods to access the properties of the object by an index.&lt;/li>
&lt;/ul>
&lt;p>The most common case, in which the methods are implemented using the
&lt;code>metaclass&lt;/code>{.interpreted-text role=&amp;ldquo;ref&amp;rdquo;} system, is supported by
deriving the class from &lt;code>CValueObject&lt;/code>, which is a convenience class
template which derives from all the most commonly used mixin classes,
using multiple inheritance.&lt;/p>
&lt;h1 id="meta-types-and-cvariant">Meta types and &lt;code>CVariant&lt;/code>&lt;/h1>
&lt;p>Any of our value objects can be stored in a [CVariant]{.title-ref}, and
the canonical methods of the stored object can be accessed through the
methods of &lt;code>CVariant&lt;/code>. This is facilitated by a meta type system built
on top of Qt's meta type system, using
&lt;code>BlackMisc::registerMetaValueType()&lt;/code> and &lt;a href="https://en.wikipedia.org/wiki/Duck_typing">duck
typing&lt;/a>. This allows value
objects to be treated polymorphically while retaining value semantics
and without introducing virtual methods in the public API.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> It is not
neccessary for all of the canonical methods to be present in an object
stored in a &lt;code>CVariant&lt;/code>; it is a runtime error to attempt to use a method
of a &lt;code>CVariant&lt;/code> storing an object which doesn't support that method.&lt;/p>
&lt;h1 id="mixin-classes">Mixin classes&lt;/h1>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Some Q&amp;amp;A about mixins from the meetings
&lt;a href="https://dev.vatsim-germany.org/boards/22/topics/2672?r=2676#message-2676">here&lt;/a>.
:::&lt;/p>
&lt;p>Sometimes it doesn't make sense for a particular value class to
implement one or more of the canonical methods. In these cases, instead
of deriving from &lt;code>CValueObject&lt;/code>, a value class can derive directly from
the specific mixin classes which it needs. This allows for extensive
code reuse through inheritance without violating the &lt;a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov
substitution
principle&lt;/a>
and without coupling together unrelated responsibilities. All of the
mixin classes, as well as &lt;code>CValueObject&lt;/code>, use the
&lt;a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP&lt;/a>.
Some of the mixins require their template argument type to satisfy
particular
&lt;a href="https://en.wikipedia.org/wiki/Concept_%28generic_programming%29">concepts&lt;/a>.
This is documented in their Doxygen class documentation. The concepts
required when deriving from &lt;code>CValueObject&lt;/code> are the union of all the
required concepts of the mixins which &lt;code>CValueObject&lt;/code> uses.&lt;/p>
&lt;h1 id="inheritance">Inheritance&lt;/h1>
&lt;p>Occasionally, we have value classes which represent specializations of
other value classes, and therefore derive from those other value
classes. For example, &lt;code>CHeading&lt;/code> derives from &lt;code>CAngle&lt;/code>, and &lt;code>CAltitude&lt;/code>
derives from &lt;code>CLength&lt;/code>. In these cases, there is a base class which
derives from certain mixins, and a derived class which derives from the
base class and some other mixins. A base and a derived class might
derive from some of the same mixins. For example, &lt;code>CAngle&lt;/code> derives from
&lt;code>Mixin::MetaType&amp;lt;CAngle&amp;gt;&lt;/code> and &lt;code>CHeading&lt;/code> derives from
&lt;code>Mixin::MetaType&amp;lt;CHeading&amp;gt;&lt;/code>. In these cases, it is necessary to use a
&lt;a href="http://en.cppreference.com/w/cpp/language/using_declaration#In_class_definition">using
declaration&lt;/a>
to disambiguate which methods should be inherited in the derived class.
In this example, the definition of &lt;code>CHeading&lt;/code> has a
&lt;code>using Mixin::MetaType&amp;lt;CHeading&amp;gt;::registerMetadata;&lt;/code> to tell the
compiler that it wants to inherit the &lt;code>registerMetadata&lt;/code> method of
&lt;code>Mixin::MetaType&amp;lt;CHeading&amp;gt;&lt;/code>, not the &lt;code>registerMetadata&lt;/code> method of
&lt;code>CAngle&lt;/code>. To reduce duplication of these &lt;code>using&lt;/code> declarations, there are
macros provided with the mixin classes to automatically introduce the
appropriate declarations into a derived class.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Virtual methods in frequently-used CRTP class templates have a
detrimental effect on compilation times, because they inhibit lazy
instantiation of methods. &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Docs: Directory structure</title><link>https://swift-project.github.io/docs/dev/dirstructure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/dirstructure/</guid><description>
&lt;p>on MacOS: see &lt;a href="http://doc.qt.io/qt-5/osx-deployment.html">http://doc.qt.io/qt-5/osx-deployment.html&lt;/a>&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">bin
plugins
swift.app
Contents
MacOS (same as Qt application Directory)
swift
lib
share
&lt;/code>&lt;/pre>&lt;p>Win, Linux&lt;/p>
&lt;pre>&lt;code>
bin (same as Qt application Directory)
plugins
lib
share
&lt;/code>&lt;/pre></description></item><item><title>Docs: Draft protocol spec: aircraft parts configuration packets for FSD</title><link>https://swift-project.github.io/docs/dev/acconfig/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/acconfig/</guid><description>
&lt;p>::: {.warning}
::: {.title}
Warning
:::&lt;/p>
&lt;p>This protocol specification is work in progress. Do not yet use it for
implementation.
:::&lt;/p>
&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>This specification is meant to be an extension to the existing
propritary VATSIM protocol. This is driven by the fact, that the VATSIM
protocol is lacking several important information like the position of
gear, flaps, setting of lights or even the an on-ground flag. The idea
of this protocol extension is to use JSON objects to have a easy to
extend and easy to read paackage. It is sent via the custom packet
functionality of FSD. This means, you are able to send each JSON string
to a specific callsign.&lt;/p>
&lt;h1 id="why-json">Why JSON?&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>It is easy for humans to read and write. It is easy for machines to
parse and generate.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Almost every information can be sent as JSON object&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Objects can be nested&lt;/li>
&lt;li>All relevant data types are available&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>Information are sent as objects. Although we have &lt;strong>not&lt;/strong> yet
discussed it, this could be a solution for FSD 2.0 as well.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JSON is well supported by frameworks: &lt;a href="http://www.json.org/">http://www.json.org/&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JSON is de facto standard for data transfer via web services&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Easy to extend without breaking compatibility, new attributes can
just be added.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Example:&lt;/p>
&lt;pre>&lt;code class="language-{.js}" data-lang="{.js}">{
&amp;quot;strobe&amp;quot;: false,
&amp;quot;landing&amp;quot;: false
}
&lt;/code>&lt;/pre>&lt;p>could be easily extended to&lt;/p>
&lt;pre>&lt;code class="language-{.js}" data-lang="{.js}">{
&amp;quot;strobe&amp;quot;: false,
&amp;quot;landing&amp;quot;: false,
&amp;quot;taxi&amp;quot;: true,
}
&lt;/code>&lt;/pre>&lt;p>Very likely the 2nd response is still compliant with legacy systems of
the first generation.&lt;/p>
&lt;ul>
&lt;li>Character encoding (see below) will allow us to use the full unicode
set and hence avoids encoding issues as in the current FSD packages.&lt;/li>
&lt;/ul>
&lt;h1 id="json-datatypes">JSON DataTypes&lt;/h1>
&lt;p>The following tables shows all possible JSON types:&lt;/p>
&lt;hr>
&lt;p>Type Description&lt;/p>
&lt;hr>
&lt;p>Number double-precision floating-point format in JavaScript&lt;/p>
&lt;p>String double-quoted Unicode with backslash escaping&lt;/p>
&lt;p>Boolean true or false&lt;/p>
&lt;p>Array an ordered sequence of values&lt;/p>
&lt;p>Value it can be a string, a number, true or false, null etc&lt;/p>
&lt;p>Object an unordered collection of key:value pairs&lt;/p>
&lt;p>Whitespace can be used between any pair of tokens&lt;/p>
&lt;h2 id="null---------empty">null empty&lt;/h2>
&lt;h1 id="object-definitions">Object Definitions&lt;/h1>
&lt;h2 id="lights">Lights&lt;/h2>
&lt;p>The lights object is used to synchronize the aircraft lights.&lt;/p>
&lt;pre>&lt;code class="language-{.js}" data-lang="{.js}">{
&amp;quot;strobe&amp;quot;: false,
&amp;quot;landing&amp;quot;: false,
&amp;quot;taxi&amp;quot;: true,
&amp;quot;beacon&amp;quot;: false,
&amp;quot;nav&amp;quot;: true,
&amp;quot;logo&amp;quot;: false
}
&lt;/code>&lt;/pre>&lt;p>Each light can be switched on or off individually.&lt;/p>
&lt;p>Values:&lt;/p>
&lt;p>&lt;code>true&lt;/code>: Light is switched on.&lt;/p>
&lt;p>&lt;code>false&lt;/code>: Light is switched off.&lt;/p>
&lt;p>default: Light is switched on.&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: FSX supports toggling the recognition lights. How about adding a
&amp;quot;recog&amp;quot; property to the lights object?
:::&lt;/p>
&lt;h2 id="gear">Gear&lt;/h2>
&lt;p>The gear object contains maximum 3 positions.&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: do we really need three separate gear values? If the three values
didn't all have the same value, that would mean a gear malfunction, and
that's extremely rare. I don't think it's worth the extra packet
size.
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Mat: I like the idea of being able to observe asymmetric gear failure.
The packet is only sent when something changes. If packet size was such
a big deal we wouldn't be using plain text. But the three position
maximum is insufficient for all aircraft types (e.g. 747 needs four:
left, center, right, and nose). If the choice is between one value and
three values, I prefer one. But I also think we could come up with a
solution to support an arbitrary number of values, and still have the
smaller packet size in the case when all values are equal. (e.g. [{
&amp;quot;all&amp;quot;: true }]{.title-ref} or [{ &amp;quot;all&amp;quot;: true, &amp;quot;nose&amp;quot;: false
}]{.title-ref})
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: Correct me if I'm wrong, but in order to implement the &amp;quot;all&amp;quot;
value, it would need to be a tri-state. There would need to be a way for
the client to know to ignore the value of &amp;quot;all&amp;quot; and instead look at
the value of the individual gear positions. Remember that we're
omitting values that are equal to the default. Personally I don't think
this is worth it for the extremely rare event of a gear malfunction.
:::&lt;/p>
&lt;pre>&lt;code class="language-{.js}" data-lang="{.js}">{
&amp;quot;center&amp;quot;: true,
&amp;quot;left&amp;quot;: true,
&amp;quot;right&amp;quot;: true
}
&lt;/code>&lt;/pre>&lt;p>Values:&lt;/p>
&lt;p>&lt;code>true&lt;/code>: Gear is extended.&lt;/p>
&lt;p>&lt;code>false&lt;/code>: Gear is retracted.&lt;/p>
&lt;p>default: Gear is retracted.&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: I'm wondering if the default should be gear down, since that will
be the case for most of the aircraft you encounter during a flight.
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Mat: agreed.
:::&lt;/p>
&lt;h2 id="flaps">Flaps&lt;/h2>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">{
&amp;quot;trailing_edge_flaps&amp;quot;: false,
&amp;quot;leading_edge_flaps&amp;quot;: false
}
&lt;/code>&lt;/pre>&lt;p>Values:&lt;/p>
&lt;p>&lt;code>true&lt;/code>: Flap is extended.&lt;/p>
&lt;p>&lt;code>false&lt;/code>: Flap is retracted.&lt;/p>
&lt;p>default: Flap is retracted.&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: I propose shortening these property names to
[trailing_edge]{.title-ref} and [leading_edge]{.title-ref} since the
[_flaps]{.title-ref} suffix is redundant.
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Mat: [flaps]{.title-ref} and [slats]{.title-ref} would be even shorter.
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: Indeed ... I was suggesting removing the [_flaps]{.title-ref}
suffix only to remove the redundancy. I wasn't looking to save length.
Changing it to [flaps]{.title-ref} and [slats]{.title-ref} would
re-introduce redundancy again since the object name is
[flaps]{.title-ref}. Perhaps we just eliminate the [flaps]{.title-ref}
object and just have top level [flaps]{.title-ref} and
[slats]{.title-ref} properties. (I'm actually still in favor of a flat
key/value pair list instead of using nested objects anyway. I feel like
the nested object hierarchy just bleeds implementation details into the
protocol, but I don't feel all that strongly about it either way.)
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Mat: If we go with a single value for landing gear, then it would be
consistent to also have a single value covering both flaps and slats.
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: A single [flaps_down]{.title-ref} value works for me, because as
far as I know you can't have flaps extended without slats (or
vice-versa) unless there's a malfunction. At least that's the case
with any aircraft I've flown. That's also supported by the fact that
there is no SimConnect event for extending/retracting the slats. (No
that that's definitive, just pointing it out.)
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: Once I dug into this a bit more while implementing this
functionality in vPilot, I'm realizing that it might make more sense to
have the flaps value be an integer (representing the percent of
extension, with zero as the default) rather than a boolean. This would
allow us to distinguish between takeoff and landing flaps settings.
Thoughts?
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Roland: I had thought about it in the very beginning. If we do it, I
would recommend to send numbers with low frequency or only steps. {nav
Flaps 0 &amp;gt; Flaps 10 &amp;gt; Flaps 15} etc.
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Ross: I considered that as well, but not all aircraft use the same
values for degrees when referencing various levels of flap extension.
How would the client know which levels are supported by any given
aircraft model? Also, FSX/P3D allow reading/writing the flaps value as a
percentage, not as a number of degrees. I assume that's because of the
fact that not all aircraft use the same number of degrees for various
flap settings. I'm not sure how XPlane works in this regard. Should we
move this discussion to the forum thread we already have going? Not sure
who all has access to that...
:::&lt;/p>
&lt;p>::: {.note}
::: {.title}
Note
:::&lt;/p>
&lt;p>Discussion continued at
&lt;a href="https://dev.vatsim-germany.org/boards/11/topics/1592?r=2235">https://dev.vatsim-germany.org/boards/11/topics/1592?r=2235&lt;/a>
:::&lt;/p>
&lt;h2 id="spoilers">Spoilers&lt;/h2>
&lt;pre>&lt;code class="language-{.js}" data-lang="{.js}">{
&amp;quot;left&amp;quot;: false,
&amp;quot;right&amp;quot;: false
}
&lt;/code>&lt;/pre>&lt;p>Values:&lt;/p>
&lt;p>&lt;code>true&lt;/code>: Spoilers are extended.&lt;/p>
&lt;p>&lt;code>false&lt;/code>: Spoilers are retracted.&lt;/p>
&lt;p>default: Spoilers are retracted.&lt;/p>
&lt;h2 id="on-ground-flag">On Ground Flag&lt;/h2>
&lt;p>Legacy FSD does not provide information if an aircraft is on ground.
This object will add it.&lt;/p>
&lt;pre>&lt;code class="language-{.js}" data-lang="{.js}">&amp;quot;on_ground&amp;quot;: true
&lt;/code>&lt;/pre>&lt;p>Values:&lt;/p>
&lt;p>&lt;code>true&lt;/code>: Aircraft is on ground.&lt;/p>
&lt;p>&lt;code>false&lt;/code>: Aircraft is flying.&lt;/p>
&lt;p>default: Aircraft is flying.&lt;/p>
&lt;h2 id="engines-running-flag">Engines Running Flag&lt;/h2>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">&amp;quot;engines_running&amp;quot;: true
&lt;/code>&lt;/pre>&lt;p>Values:&lt;/p>
&lt;p>&lt;code>true&lt;/code>: Aircraft engines are running.&lt;/p>
&lt;p>&lt;code>false&lt;/code>: Aircraft engines are not running.&lt;/p>
&lt;p>default: [true]{.title-ref}.&lt;/p>
&lt;h2 id="default-values">Default values&lt;/h2>
&lt;p>Each Object has a defined default value. In case a key is missing in the
JSON object, the receiver client shall fill missing key/value pairs with
default value. The sending client shall always skip key/value pairs
which are identical to default in order to reduce bandwidth.&lt;/p>
&lt;h1 id="protocol">Protocol&lt;/h1>
&lt;h2 id="supporting-clients">Supporting Clients&lt;/h2>
&lt;p>Since this protocol is quite new, all legacy clients will not understand
and ignore aircraft configuration packets. In order to reduce bandwidth
and safe CPU time, the client shall send packets only to clients which
have support for aircraft configuration packets declared in their
[CAPS]{.title-ref} packet. Supporting clients have the following
key/value pair defined:&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">ACCONFIG=1
&lt;/code>&lt;/pre>&lt;p>Packets shall only pushed to clients, which have this [CAPS]{.title-ref}
value defined.&lt;/p>
&lt;p>The list of clients is currently:&lt;/p>
&lt;ul>
&lt;li>vPilot&lt;/li>
&lt;li>&lt;em>swift&lt;/em>&lt;/li>
&lt;/ul>
&lt;h2 id="range">Range&lt;/h2>
&lt;p>In order to reduce traffic load, the client should send configuration
packets only to remote aircrafts in a defined range (recommended are
&lt;code>10 nm&lt;/code>, but a client developer might let the user configure it).&lt;/p>
&lt;h2 id="pushing-a-new-configuration-packet">Pushing a new Configuration Packet&lt;/h2>
&lt;p>When a callsign/aircraft, which accepts configuration packets (see
&lt;code>CAPS&lt;/code> value), enters the defined range the first time from a client
perspective, the client shall send send a full configuration packet
immediately and also a full packet anytime something has changed. To
reduce bandwidth and size of the packet, default values shall be taken
into account.&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">{
&amp;quot;lights&amp;quot;: {
&amp;quot;strobe&amp;quot;: false,
&amp;quot;landing&amp;quot;: false,
&amp;quot;beacon&amp;quot;: false,
&amp;quot;logo&amp;quot;: false
},
&amp;quot;gear&amp;quot;: {
&amp;quot;center&amp;quot;: true,
&amp;quot;left&amp;quot;: true,
&amp;quot;right&amp;quot;: true
},
&amp;quot;flaps&amp;quot;: {
},
&amp;quot;spoilers&amp;quot;: {
},
&amp;quot;on_ground&amp;quot;: true
}
&lt;/code>&lt;/pre>&lt;p>Missing pairs in object &lt;code>lights&lt;/code> have to be replaced by default values.
&lt;code>flaps&lt;/code> and &lt;code>spoilers&lt;/code> are empty, this means the default value applies
to all pairs.&lt;/p>
&lt;p>::: {.todo}
Maximum length payload?
:::&lt;/p>
&lt;h1 id="character-encoding">Character Encoding&lt;/h1>
&lt;p>To avoid conflicts with non-ASCII characters either in FSD or on the
client side, all non-ASCII characters inside string values shall be
encoded via JSON character escape sequence, defined in the JSON
specification (&lt;a href="http://www.ietf.org/rfc/rfc4627.txt">RFC4627&lt;/a> chapter
2.5 Strings):&lt;/p>
&lt;ul>
&lt;li>If the character is in the Basic Multilingual Plane (&lt;code>U+0000&lt;/code>
through &lt;code>U+FFFF&lt;/code>), then it may be represented as a six-character
sequence: a reverse solidus, followed by the lowercase letter &lt;code>u&lt;/code>,
followed by four hexadecimal digits that encode the character's
code point. The hexadecimal letters &lt;code>A&lt;/code> though &lt;code>F&lt;/code> can be upper or
lowercase. So, for example, a string containing only a single
reverse solidus character may be represented as &lt;code>&amp;quot;\u005C&amp;quot;&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Examples:&lt;/p>
&lt;hr>
&lt;p>non-ASCII character Unicode Escaped sequence&lt;/p>
&lt;hr>
&lt;p>à U+00E0 u00E0&lt;/p>
&lt;p>ȹ U+0239 u0239&lt;/p>
&lt;p>Ŧ U+0166 u0166&lt;/p>
&lt;h2 id="ý---------------------u00fd----u00fd">ý U+00FD u00FD&lt;/h2>
&lt;p>Most JSON parsers support automatically character escaping.&lt;/p>
&lt;p>Example Qt implementation to escape characters&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">#include &amp;lt;QCoreApplication&amp;gt;
#include &amp;lt;QDebug&amp;gt;
QString convertToUnicodeEscaped(const QString &amp;amp;str)
{
QString escaped;
for (QString::const_iterator it = str.begin(); it != str.end(); ++it)
{
QChar ch = *it;
ushort code = ch.unicode();
if (code &amp;lt; 0x80)
{
escaped += ch;
}
else
{
escaped += &amp;quot;\\u&amp;quot;;
escaped += QString::number(code, 16).rightJustified(4, '0');
}
}
return escaped;
}
int main(int argc, char *argv[])
{
QCoreApplication a(argc, argv);
QString str(&amp;quot;This is a Test string with ßÜÖЗдравствуй&amp;quot;);
qDebug() &amp;lt;&amp;lt; convertToUnicodeEscaped(str);
&lt;/code>&lt;/pre>&lt;p>Output:&lt;/p>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">This is a Test string with \u00df\u00dc\u00d6\u0417\u0434\u0440\u0430\u0432\u0441\u0442\u0432\u0443\u0439
&lt;/code>&lt;/pre>&lt;h1 id="open-questions">Open questions&lt;/h1>
&lt;p>Maximum length of payload for such a JSON message. Is the length
sufficient? Btw, what is the maximum length anyway?&lt;/p></description></item><item><title>Docs: Facade classes (aka contexts)</title><link>https://swift-project.github.io/docs/dev/facade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/facade/</guid><description>
&lt;div class="alert alert-primary" role="alert">
&lt;h4 class="alert-heading">Note&lt;/h4>
&lt;em>Boon and bane&lt;/em>
&lt;/div>
&lt;h1 id="characteristics-of-the-contexts">Characteristics of the contexts:&lt;/h1>
&lt;ul>
&lt;li>Facade for a set of domain functionality&lt;/li>
&lt;li>Smallest unit registered with DBus, hence smallest unit which can be
used remotely&lt;/li>
&lt;/ul>
&lt;h1 id="characteristics-of-the-runtime">Characteristics of the runtime&lt;/h1>
&lt;ul>
&lt;li>Owns the DBus server (if applicable, server side) or the DBus
connection (client side) - &lt;code>initDBusServer&lt;/code>&lt;/li>
&lt;li>Factory for contexts&lt;/li>
&lt;li>Loads the settings (not only for other contexts, but also DBus
server)&lt;/li>
&lt;li>Connects cross context signal / slots (&lt;code>initPostSetup&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h1 id="cross-context-dependency">Cross context dependency&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>context / depends on&lt;/th>
&lt;th>audio&lt;/th>
&lt;th>app&lt;/th>
&lt;th>network&lt;/th>
&lt;th>settings&lt;/th>
&lt;th>simulator&lt;/th>
&lt;th>own aircraft&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>audio&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>application&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>x&lt;/td>
&lt;td>x&lt;/td>
&lt;td>x&lt;/td>
&lt;td>x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>network&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>settings&lt;/td>
&lt;td>x&lt;/td>
&lt;td>x&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>x&lt;/td>
&lt;td>x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>simulator&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>x&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>own aircraft&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>x&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="review-for-future-swift-versions">Review (for future swift versions)&lt;/h1>
&lt;p>Know shortcomings:&lt;/p>
&lt;ul>
&lt;li>Cross dependencies, the ideal design goal is to have independent
contexts. The idea was that each context can be enabled/disabled,
but the goal was not achieved.&lt;/li>
&lt;li>DBus communication is not bidirectional. The audio context can run
on core or on GUI, but the proxy/implementation object can not just
be switched (at least not for peer 2 peer DBus).&lt;/li>
&lt;li>Our design was planned around the runtime/contexts. But
launcher/mapping tool do not need contexts.&lt;/li>
&lt;/ul>
&lt;p>Keep in mind for future versions:&lt;/p>
&lt;ul>
&lt;li>We still transfer mass data (i.e. relatively large amounts of data, like all remote aircraft or models).&lt;/li>
&lt;li>Therefore we use pull to avoid overloads.&lt;/li>
&lt;li>Any future distributed objects system needs to consider that. Automatic object distribution might be fatal.&lt;/li>
&lt;/ul></description></item><item><title>Docs: Hotkeys (architecture)</title><link>https://swift-project.github.io/docs/dev/hotkeys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/hotkeys/</guid><description>
&lt;h1 id="general">General&lt;/h1>
&lt;p>Across the chapters, the following definitions shall apply:&lt;/p>
&lt;p>&lt;strong>Hotkey Source (Device)&lt;/strong>: Implementation or device object, which can
trigger a hotkey function, e.g. keyboard, joystick, remote event&lt;/p>
&lt;p>&lt;strong>Hotkey Action&lt;/strong>: String based object with hierarchical syntax,
describing and grouping hotkey purpose, e.g. push-to-talk&lt;/p>
&lt;p>&lt;strong>Hotkey Receiver Object:&lt;/strong> Any kind of object which registers one if
its methods for a Hotkey Function&lt;/p>
&lt;h1 id="object-interface-overview">Object Interface Overview&lt;/h1>
&lt;p>Different objects and interfaces are involved and will be explained in
details below&lt;/p>
&lt;h2 id="interface-cinputmanager-vs-hotkey-receiver-objects">Interface &lt;code>CInputManager&lt;/code> vs. &lt;code>Hotkey Receiver Objects&lt;/code>&lt;/h2>
&lt;p>First of all a hotkey receiver object is an object which exposes one or
more of its methods as hotkey method. Typical examples are
&lt;code>CContextAudio&lt;/code> for push to talk and GUI for different GUI hotkeys.&lt;/p>
&lt;p>Sources and receivers of a hotkey action are not coupled. A receiver
does not know which source triggered the hotkey action. The same is
applicable the other way round. A source does not know, which hotkey
function it might trigger - if any. The mapping logic is done in
&lt;code>CInputManager&lt;/code>. It is the central node wiring source and receiver
together.&lt;/p>
&lt;p>&lt;img src="http://img.swift-project.org/input_manager.png" alt="image">&lt;/p>
&lt;p>Hotkey receiver objects bind a method to a hotkey action. The hotkey
action is a string with a hierarchical syntax, e.g. &lt;code>/Test/Message&lt;/code>.
&lt;code>Test&lt;/code> stands for an arbitrary group into which &lt;code>Message&lt;/code> belongs. This
syntax can be used to logically group hotkeys together. No
&lt;code>Hotkey Source&lt;/code> is involved at this stage (no keyboard keys, no joystick
etc). To the object itself it is transparent which &lt;code>Hotkey Source&lt;/code> the
call had issued.&lt;/p>
&lt;p>Usage example:
&lt;code>BlackCore::CActionBind m_action { &amp;quot;/Test/Message&amp;quot;, this, &amp;amp;CFoo::bar };&lt;/code>&lt;/p>
&lt;h2 id="interface-cinputmanager-vs-hotkey-source-device">Interface &lt;code>CInputManager&lt;/code> vs. &lt;code>Hotkey Source (Device)&lt;/code>&lt;/h2>
&lt;p>&lt;img src="http://img.swift-project.org/input_keyboard_joystick.png" alt="image">&lt;/p>
&lt;p>&lt;code>CInputManager&lt;/code> will feed all configured keys/buttons to the
corresponding device interface. Registered &lt;code>CKeyboardKeys&lt;/code> will be
registered in &lt;code>IKeyboard&lt;/code>, joystick buttons will be registered in
&lt;code>IJoystick&lt;/code>. &lt;code>IKeyboard&lt;/code> and &lt;code>IJoystick&lt;/code> will signal back if one of the
registered keys/buttons have been pressed. No actions are involved at
this stage. &lt;code>CInputManager&lt;/code> knows, which &lt;code>Hotkey Receiver Objects&lt;/code> are
registered and will call their functions.&lt;/p>
&lt;p>Advantages:&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Only keys need to be registered which have to be monitored locally&lt;/li>
&lt;li>Can be extended easily by adding a new input device.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="hotkey-action-forwarding-to-remote">Hotkey Action forwarding to Remote&lt;/h2>
&lt;p>Hotkey actions do not have to be limited to local execution. If
forwarding is enabled, all triggered actions will be forwarded to a
remote process running on any machine. This allows for example to
configure a push to talk hotkey on one machine, even though core is
running in a different process.&lt;/p>
&lt;p>&lt;img src="http://img.swift-project.org/Input_Manager_Events.png" alt="image">&lt;/p>
&lt;p>Advantages:&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Only one event type is required, even if more input devices are
added&lt;/li>
&lt;li>Remote &lt;code>CInputManager&lt;/code> does not need to know the configuration of
the local GUI, it will just react on the given inputs from DBus.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="interface-cinputmanager-vs-settings">Interface &lt;code>CInputManager&lt;/code> vs. &lt;code>Settings&lt;/code>&lt;/h2>
&lt;p>&lt;code>CInputManager&lt;/code> is interfacing with the settings API. The list of action
hotkeys - which is the mapping between a hotkey combination and the
hotkey action is loaded during start up and modifications saved to disk.&lt;/p>
&lt;h1 id="summary">Summary&lt;/h1>
&lt;p>The design is conceptual only. It addresses the new requirements of
different instead of only one input device. Input has to be transparent
(keyboard, joystick, event, anything else) and decoupling of different
objects is IMHO good OO design. It hopefully reduces complexity within
swift a lot.&lt;/p></description></item><item><title>Docs: Logging</title><link>https://swift-project.github.io/docs/dev/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/logging/</guid><description>
&lt;h1 id="sending-log-messages">Sending log messages&lt;/h1>
&lt;h2 id="simple-generic-messages">Simple generic messages&lt;/h2>
&lt;p>The &lt;code>qDebug&lt;/code>, &lt;code>qWarning&lt;/code>, and &lt;code>qCritical&lt;/code>
&lt;a href="http://qt-project.org/doc/qt-5/debug.html#warning-and-debugging-messages">macros&lt;/a>
can be used for sending quick and simple messages for development
purposes. By default, they are always emitted to the console. They can
also be picked up by &lt;code>BlackMisc::CLogHandler&lt;/code>, just like the categorized
messages can.&lt;/p>
&lt;h2 id="categorized-messages">Categorized messages&lt;/h2>
&lt;p>::: {.todo}
See also: &lt;code>CLogMessage&lt;/code> doxygen link.
:::&lt;/p>
&lt;p>Giving each message a category allows it to be handled more
intelligently. Qt provides native support for &lt;a href="http://qt-project.org/doc/qt-5/qloggingcategory.html">logging
categories&lt;/a>.
&lt;code>BlackMisc::CLogMessage&lt;/code> is a wrapper around
&lt;a href="http://qt-project.org/doc/qt-5/qdebug.html">QDebug&lt;/a> with a slightly
different API. The normal use case is based around creating a temporary
instance of &lt;code>CLogMessage&lt;/code>. When the temporary is destroyed at the end of
the full expression, the message is sent, which is similar to how
&lt;code>QDebug&lt;/code> works.&lt;/p>
&lt;h2 id="the-default-category">The default category&lt;/h2>
&lt;p>If &lt;code>CLogMessage&lt;/code> is used without specifying a category, then the value
&lt;code>CLogMessage::defaultMessageCategory()&lt;/code> is used (&lt;code>&amp;quot;swift&amp;quot;&lt;/code>).&lt;/p>
&lt;p>This will send a debug message created by concatenating the streamed
values:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">CLogMessage() &amp;lt;&amp;lt; &amp;quot;the time is&amp;quot; &amp;lt;&amp;lt; time &amp;lt;&amp;lt; &amp;quot;and there are&amp;quot; &amp;lt;&amp;lt; planes.size() &amp;lt;&amp;lt; &amp;quot;planes in the sky&amp;quot;;
&lt;/code>&lt;/pre>&lt;p>This will send an info message created by substituting the &lt;code>%1&lt;/code>,
&lt;code>%2&lt;/code>,... placeholders for the streamed values: (see QString
documentation)&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">CLogMessage().info(&amp;quot;The time is %1 and there are %2 planes in the sky&amp;quot;) &amp;lt;&amp;lt; time &amp;lt;&amp;lt; planes.size();
&lt;/code>&lt;/pre>&lt;p>Similarly these will send a warning or error message:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">CLogMessage().warning(&amp;quot;%1 is not a valid ICAO code&amp;quot;) &amp;lt;&amp;lt; icao;
CLogMessage().error(&amp;quot;%1 is not a valid ICAO code&amp;quot;) &amp;lt;&amp;lt; icao;
&lt;/code>&lt;/pre>&lt;h2 id="specifying-a-category">Specifying a category&lt;/h2>
&lt;p>An explicit category string can be specified when using &lt;code>CLogMessage&lt;/code>.&lt;/p>
&lt;p>This will send a debug message created by concatenating the streamed
values:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">CLogMessage().debug(&amp;quot;swift.planes.counter.timed&amp;quot;) &amp;lt;&amp;lt; &amp;quot;the time is&amp;quot; &amp;lt;&amp;lt; time &amp;lt;&amp;lt; &amp;quot;and there are&amp;quot; &amp;lt;&amp;lt; planes.size() &amp;lt;&amp;lt; &amp;quot;planes in the sky&amp;quot;;
&lt;/code>&lt;/pre>&lt;p>This will send an info message created by substituting the &lt;code>%1&lt;/code>,
&lt;code>%2&lt;/code>,... placeholders for the streamed values:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">CLogMessage().info(&amp;quot;swift.planes.counter.timed&amp;quot;, &amp;quot;The time is %1 and there are %2 planes in the sky&amp;quot;) &amp;lt;&amp;lt; time &amp;lt;&amp;lt; planes.size();
&lt;/code>&lt;/pre>&lt;p>Similarly these will send a warning or error message:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">CLogMessage().warning(&amp;quot;swift.icao.validation&amp;quot;, &amp;quot;%1 is not a valid ICAO code&amp;quot;) &amp;lt;&amp;lt; icao;
CLogMessage().error(&amp;quot;swift.icao.validation&amp;quot;, &amp;quot;%1 is not a valid ICAO code&amp;quot;) &amp;lt;&amp;lt; icao;
&lt;/code>&lt;/pre>&lt;h2 id="parameterizing-the-category">Parameterizing the category&lt;/h2>
&lt;p>Hard-coded category strings are hard to maintain and easy to get wrong.
Instead of passing an explicit string, it is possible to pass a pointer
to any object of class type, and the category string will be obtained by
calling &lt;code>-&amp;gt;getMessageCategory()&lt;/code> on that pointer.&lt;/p>
&lt;p>A class which sends log messages should define its own category string
method:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">class CTimedPlaneCounter
{
public:
static QString getMessageCategory() { return &amp;quot;swift.planes.counter.timed&amp;quot;; }
//...
};
&lt;/code>&lt;/pre>&lt;p>Then this will send a debug message created by concatenating the
streamed values:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">void CTimedPlaneCounter::count()
{
//...
CLogMessage().debug(this) &amp;lt;&amp;lt; &amp;quot;the time is&amp;quot; &amp;lt;&amp;lt; time &amp;lt;&amp;lt; &amp;quot;and there are&amp;quot; &amp;lt;&amp;lt; planes.size() &amp;lt;&amp;lt; &amp;quot;planes in the sky&amp;quot;;
}
&lt;/code>&lt;/pre>&lt;p>This will send an info message created by substituting the &lt;code>%1&lt;/code>,
&lt;code>%2&lt;/code>,... placeholders for the streamed values:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">void CTimedPlaneCounter::count()
{
//...
CLogMessage().info(this, &amp;quot;The time is %1 and there are %2 planes in the sky&amp;quot;) &amp;lt;&amp;lt; time &amp;lt;&amp;lt; planes.size();
}
&lt;/code>&lt;/pre>&lt;p>Similarly these will send a warning or error message:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">void CIcaoValidator::validate()
{
//...
CLogMessage().warning(this, &amp;quot;%1 is not a valid ICAO code&amp;quot;) &amp;lt;&amp;lt; icao;
CLogMessage().error(this, &amp;quot;%1 is not a valid ICAO code&amp;quot;) &amp;lt;&amp;lt; icao;
}
&lt;/code>&lt;/pre>&lt;h1 id="directly-returning-log-messages">Directly returning log messages&lt;/h1>
&lt;p>&lt;code>CLogMessage&lt;/code> is implicitly convertible to &lt;code>CStatusMessage&lt;/code>. This means
that a &lt;code>CLogMessage&lt;/code> expression can appear in a &lt;code>return&lt;/code> statement of a
method which returns &lt;code>CStatusMessage&lt;/code>, so the caller of the method can
have direct, synchronous access to the message which was the result of
the method:&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">CStatusMessage CFoo::doSomething()
{
//...
return CLogMessage() &amp;lt;&amp;lt; &amp;quot;something went wrong&amp;quot;;
}
&lt;/code>&lt;/pre>&lt;p>The message is still emitted and can still be handled by &lt;code>CLogHandler&lt;/code>
as normal. See &amp;quot;Implementation challenges&amp;quot; below for information on
avoiding double handling of such messages.&lt;/p>
&lt;h1 id="receiving-log-messages">Receiving log messages&lt;/h1>
&lt;h2 id="signals-for-all-messages">Signals for all messages&lt;/h2>
&lt;p>::: {.todo}
See also: &lt;code>CStatusMessage&lt;/code> doxygen link.
:::&lt;/p>
&lt;p>&lt;code>CLogHandler&lt;/code> is a class for subscribing to log messages in different
categories. The singleton pointer is obtained from
&lt;code>CLogHandler::instance()&lt;/code>.&lt;/p>
&lt;p>::: {.warning}
::: {.title}
Warning
:::&lt;/p>
&lt;p>&lt;code>CLogHandler&lt;/code> can not be used in plugins, because of the singleton
pattern.
:::&lt;/p>
&lt;p>The application's &lt;code>main&lt;/code> function should call
&lt;code>CLogHandler::instance()-&amp;gt;install()&lt;/code> to tell the handler to install
itself as the Qt message handler using
&lt;a href="http://qt-project.org/doc/qt-5/qtglobal.html#qInstallMessageHandler">qInstallMessageHandler&lt;/a>.&lt;/p>
&lt;p>&lt;code>CLogHandler&lt;/code> has two signals which can be connected to:
&lt;code>localMessageLogged&lt;/code> which is emitted when a message is logged in this
process, and &lt;code>remoteMessageLogged&lt;/code> which is emitted when a message is
relayed from a different process via DBus.&lt;/p>
&lt;h1 id="signals-for-specific-message-categories">Signals for specific message categories&lt;/h1>
&lt;p>::: {.todo}
See also: &lt;code>CStatusMessage&lt;/code> doxygen link.
:::&lt;/p>
&lt;p>&lt;code>CLogHandler&lt;/code> has a method &lt;code>handlerForCategory&lt;/code> which takes a
&lt;code>QString prefix&lt;/code> and returns a pointer to a &lt;code>CLogCategoryHandler&lt;/code> which
associates itself with all messages whose category strings start with
the given prefix.&lt;/p>
&lt;p>&lt;code>CLogCategoryHandler&lt;/code> has one signal which can be connected to:
&lt;code>messageLogged&lt;/code> which is emitted whenever a message is logged whose
category string starts with the associated prefix.&lt;/p>
&lt;h2 id="console-output">Console output&lt;/h2>
&lt;p>By default, all log messages are forwarded to the Qt default message
handler which prints them to the console. &lt;code>CLogHandler&lt;/code> has a method
&lt;code>enableConsoleOutput(bool)&lt;/code> for disabling this behaviour.
&lt;code>CLogCategoryHandler&lt;/code> also has a method &lt;code>enableConsoleOutput(bool)&lt;/code> for
enabling or disabling this behaviour at the category level.&lt;/p>
&lt;h2 id="relaying-over-dbus">Relaying over DBus&lt;/h2>
&lt;p>The application context is responsible for relaying the log messages
between the &lt;code>CLogHandler&lt;/code> instances of different processes.&lt;/p>
&lt;h1 id="subscribing">Subscribing&lt;/h1>
&lt;p>You can create a &lt;code>CLogPattern&lt;/code> to match various kinds of messages, and
then pass the &lt;code>CLogPattern&lt;/code> to &lt;code>CLogHandler&lt;/code> to obtain a handler whose
&lt;code>messageLogged&lt;/code> signal will be emitted when a message matching your
&lt;code>CLogPattern&lt;/code> is logged.&lt;/p>
&lt;p>A &lt;code>CLogPattern&lt;/code> can match messages by severity, category, combinations
of categories and severities, category prefixes, suffixes and
substrings.&lt;/p>
&lt;p>Usage examples&lt;/p>
&lt;pre>&lt;code class="language-{.cpp}" data-lang="{.cpp}">// a pattern which matches all warnings
auto pattern = CLogPattern().withSeverity(CStatusMessage::SeverityWarning);
// subscribe to all warnings
auto *handler = CLogHandler::instance()-&amp;gt;handlerForPattern(CLogPattern().withSeverity(CStatusMessage::SeverityWarning));
connect(handler, &amp;amp;CLogPatternHandler::messageLogged, this, &amp;amp;CFoo::mySlot);
// subscribe to all errors
auto *handler = CLogHandler::instance()-&amp;gt;handlerForPattern(CLogPattern().withSeverity(CStatusMessage::SeverityError));
connect(handler, &amp;amp;CLogPatternHandler::messageLogged, this, &amp;amp;CFoo::mySlot);
// subscribe to all warnings and errors
auto *handler = CLogHandler::instance()-&amp;gt;handlerForPattern(CLogPattern().withSeverityAtOrAbove(CStatusMessage::SeverityWarning));
connect(handler, &amp;amp;CLogPatternHandler::messageLogged, this, &amp;amp;CFoo::mySlot);
// subscribe to all validation warnings and validation errors
auto *handler = CLogHandler::instance()-&amp;gt;handlerForPattern(CLogPattern::exactMatch(CLogCategory::validation()).withSeverityAtOrAbove(CStatusMessage::SeverityWarning));
connect(handler, &amp;amp;CLogPatternHandler::messageLogged, this, &amp;amp;CFoo::mySlot);
// convenience to get the handler and connect the signal in the same step
CLogHandler::instance()-&amp;gt;handlerForPattern(CLogPattern::exactMatch(CLogCategory::validation()).withSeverityAtOrAbove(CStatusMessage::SeverityWarning))-&amp;gt;subscribe(this, &amp;amp;CFoo::mySlot);
// convenience for validation messages
CLogHandler::instance()-&amp;gt;handlerForValidation()-&amp;gt;subscribe(this, &amp;amp;CFoo::mySlot);
&lt;/code>&lt;/pre>&lt;p>&lt;code>CLogPattern&lt;/code> uses &lt;code>QSet&lt;/code> internally, which made it difficult to use the
meta tuple. I had to implement some of the &lt;code>CValueObject&lt;/code> methods by
hand. I didn't bother trying to find a clever workaround as I'm going
to be refactoring &lt;code>CValueObject&lt;/code> soon anyway.&lt;/p>
&lt;p>The &lt;code>topologicalSort&lt;/code> and &lt;code>isProperSubsetOf&lt;/code> stuff allows &lt;code>CLogPattern&lt;/code>
to be sorted by generality, so more specific patterns come first. For
example, &lt;code>CLogPattern::startsWith(&amp;quot;foo&amp;quot;)&lt;/code> is more general than
&lt;code>CLogPattern::startsWith(&amp;quot;foobar&amp;quot;)&lt;/code> because the latter matches a proper
subset of the messages which the former matches. This is not compatible
with the standard sorting algorithms, because in the case of
&lt;code>CLogPattern::startsWith(&amp;quot;foo&amp;quot;)&lt;/code> and &lt;code>CLogPattern::startsWith(&amp;quot;bar&amp;quot;)&lt;/code>
neither one is a subset of the other, so it is unspecified which should
come first. This functionality is used by the mechanism for selectively
enabling console output. If console output is enabled for messages
matching &lt;code>CLogPattern::startsWith(&amp;quot;foo&amp;quot;)&lt;/code> but disabled for messages
matching &lt;code>CLogPattern::startsWith(&amp;quot;bar&amp;quot;)&lt;/code> then the setting for the more
specific pattern will win.&lt;/p>
&lt;h1 id="implementation-challenges">Implementation challenges&lt;/h1>
&lt;p>Qt only supports three standard message severities: &lt;code>QtDebugMsg&lt;/code>,
&lt;code>QtWarningMsg&lt;/code>, and &lt;code>QtCriticalMsg&lt;/code>. It is necessary to map these to our
four message severities: &lt;code>Debug&lt;/code>, &lt;code>Info&lt;/code>, &lt;code>Warning&lt;/code>, and &lt;code>Error&lt;/code>.&lt;/p>
&lt;p>&lt;code>CLogMessage&lt;/code> is implicitly convertible to &lt;code>CStatusMessage&lt;/code> for directly
returning from the method which generated it (see &amp;quot;Directly returning
log messages&amp;quot; above). In order to avoid double handling of such
messages, we need a way to mark messages as having been already
potentially handled by direct return value.&lt;/p>
&lt;p>The solution to both of the above two problems is category suffix codes.
When the message is being passed through Qt's message logging
framework, we add suffixes to the category string to mark these flags.
When handling the message, the suffixes are removed, so the user of
&lt;code>CLogMessage&lt;/code> and &lt;code>CLogHandler&lt;/code> are not aware of them.&lt;/p>
&lt;p>The &lt;code>isRedundant&lt;/code> method of &lt;code>CStatusMessage&lt;/code> can be used in a slot
connected to one of the &lt;code>CLogHandler&lt;/code> or &lt;code>CLogCategoryHandler&lt;/code> signals,
to detect if the message was already potentially handled by a direct
return value from the method which generated it.&lt;/p></description></item><item><title>Docs: Meta classes</title><link>https://swift-project.github.io/docs/dev/metaclass/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/metaclass/</guid><description>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">TODO&lt;/h4>
This document is outdated and needs to be updated to reflect recent evolution of the design.
&lt;/div>
&lt;h1 id="abstract">Abstract&lt;/h1>
&lt;p>We use a system based around &lt;code>std::tuple&lt;/code> to attach declarative metadata
to the data members of value classes. The intention is to minimize the
number of places where the data members must be listed. Without this
system, each class would need separate lists of its data members for
&lt;code>operator&amp;lt;&lt;/code>, &lt;code>operator==&lt;/code>, stringification, streaming to DBus, streaming
to JSON, etc. The tuple system maintains one list of members for each
class, with optional metadata, and the methods can refer back to this
one list.&lt;/p>
&lt;h1 id="usage">Usage&lt;/h1>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">TODO&lt;/h4>
Link to Doxygen
&lt;/div>
&lt;p>In order for a class or class template to use the tuple system, it must
include the &lt;code>BLACK_ENABLE_TUPLE_CONVERSION&lt;/code> macro somewhere in its
&lt;code>private:&lt;/code> section. The macro expects one argument: the name of the
class or class template.&lt;/p>
&lt;p>The list of data members is placed in the same header file, outside of
any namespace, using the &lt;code>BLACK_DECLARE_TUPLE_CONVERSION&lt;/code> macro. The
macro expects two arguments: first, the fully qualified name of the
class or class template; second, a parenthesized, comma-separated list
of expressions, each one identifying a different data member. The
expected syntax of these expressions is described below, under
&amp;quot;Attribute Expressions&amp;quot;.&lt;/p>
&lt;p>To refer back to this list in a function implementation, call
&lt;code>TupleConverter&amp;lt;T&amp;gt;::toMetaTuple(*this)&lt;/code>, where &lt;code>T&lt;/code> is the name of the
class or class template. This returns a &lt;code>std::tuple&lt;/code> of reference
wrappers of the data members of &lt;code>*this&lt;/code>, which can be operated on by
various free functions; standard C++ already provides overloaded
comparison operators for &lt;code>std::tuple&lt;/code> which perform lexicographical
comparisons of the elements, and &lt;code>blackmisc/tuple.h&lt;/code> defines several
more, for streaming &lt;code>std::tuple&lt;/code> element-by-element to DBus, JSON, etc.&lt;/p>
&lt;p>Only member functions of &lt;code>T&lt;/code> may call &lt;code>TupleConverter&amp;lt;T&amp;gt;::toMetaTuple&lt;/code>,
otherwise this would break encapsulation.&lt;/p>
&lt;h1 id="attribute-expressions">Attribute Expressions&lt;/h1>
&lt;p>Each item in the parenthesized, comma-separated list of data members is
a C++ expression following a certain format. The permitted format is
composed of the functions and types defined in &lt;code>TupleConverterBase&lt;/code>.&lt;/p>
&lt;p>In the expression, &lt;code>o&lt;/code> is the object of type &lt;code>T&lt;/code> which was passed as the
argument to &lt;code>toMetaTuple&lt;/code>. The simplest possible attribute expression is
just &lt;code>o.m_foo&lt;/code>, where &lt;code>m_foo&lt;/code> is the name of a data member of &lt;code>T&lt;/code>. This
expression will result in the data member being entered into the list of
tuple elements with default metadata attached.&lt;/p>
&lt;p>Metadata can be added to an element through the &lt;code>attr&lt;/code> function.
&lt;code>attr(o.m_foo)&lt;/code> is identical to &lt;code>o.m_foo&lt;/code>; metadata is added by passing
additional arguments to the &lt;code>attr&lt;/code> function.&lt;/p>
&lt;h1 id="metadata">Metadata&lt;/h1>
&lt;p>These are the kinds of metadata which can be attached to the tuple
elements:&lt;/p>
&lt;ul>
&lt;li>Flags
&lt;ul>
&lt;li>Flags are used to conditionally eliminate particular members from participating in certain operations. For example, the flag &lt;code>DisabledForDBus&lt;/code> will cause the member to be ignored when streaming to DBus. The default flags is zero, meaning that a member with default metadata will participate in all operations using &lt;code>toMetaTuple&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>JSON name
&lt;ul>
&lt;li>Every member has an associated name which is used when serializing to/from JSON. The default is the name of the member with the &lt;code>m_&lt;/code> prefix removed.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="example">Example&lt;/h1>
&lt;div class="highlight">&lt;pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#000">BLACK_DECLARE_TUPLE_CONVERSION&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">BlackMisc&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">::&lt;/span>&lt;span style="color:#000">CFoo&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000;font-weight:bold">(&lt;/span>
&lt;span style="color:#000">o&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">m_apple&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// default metadata
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">attr&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">o&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">m_orange&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#4e9a06">&amp;#34;lemon&amp;#34;&lt;/span>&lt;span style="color:#000;font-weight:bold">),&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// with explicit JSON name
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span> &lt;span style="color:#000">attr&lt;/span>&lt;span style="color:#000;font-weight:bold">(&lt;/span>&lt;span style="color:#000">o&lt;/span>&lt;span style="color:#000;font-weight:bold">.&lt;/span>&lt;span style="color:#000">m_banana&lt;/span>&lt;span style="color:#000;font-weight:bold">,&lt;/span> &lt;span style="color:#000">flags&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;lt;&lt;/span>&lt;span style="color:#000">DisabledForHashing&lt;/span>&lt;span style="color:#ce5c00;font-weight:bold">&amp;gt;&lt;/span>&lt;span style="color:#000;font-weight:bold">())&lt;/span> &lt;span style="color:#8f5902;font-style:italic">// with a flag
&lt;/span>&lt;span style="color:#8f5902;font-style:italic">&lt;/span>&lt;span style="color:#000;font-weight:bold">))&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this example, &lt;code>m_apple&lt;/code> has default metadata, &lt;code>m_orange&lt;/code> has a JSON
name of &lt;code>lemon&lt;/code>, and &lt;code>m_banana&lt;/code> will not participate in hashing.&lt;/p>
&lt;h1 id="compatibility-with-previous-versions">Compatibility with previous versions&lt;/h1>
&lt;p>The following functions are provided for API compatibility with an
earlier version of the tuple system:&lt;/p>
&lt;ul>
&lt;li>&lt;code>TupleConverter&amp;lt;T&amp;gt;::toTuple&lt;/code>
&lt;ul>
&lt;li>This works like &lt;code>toMetaTuple&lt;/code>, but it ignores &lt;em>all&lt;/em> metadata.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>TupleConverter&amp;lt;T&amp;gt;::jsonMembers&lt;/code>
&lt;ul>
&lt;li>This returns a &lt;code>QStringList&lt;/code> of the JSON names of all the members. This is no longer necessary when using &lt;code>toMetaTuple&lt;/code>.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Docs: Model sets for testing</title><link>https://swift-project.github.io/docs/dev/testmodelsets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/testmodelsets/</guid><description>
&lt;p>Model sets for testing&lt;/p>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">TODO&lt;/h4>
Add FG model matching test file
&lt;/div></description></item><item><title>Docs: Relay event pattern</title><link>https://swift-project.github.io/docs/dev/relayevent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/relayevent/</guid><description>
&lt;h1 id="intent">Intent&lt;/h1>
&lt;p>Take an event triggered by an object in one of any number of processes,
and pass it to objects in any number of other processes using DBus,
without requiring those objects to make explicit use of any other class.&lt;/p>
&lt;h1 id="motivation">Motivation&lt;/h1>
&lt;p>Consider two or more processes, each one having a &lt;code>CValueCache&lt;/code> which
must be kept in sync with the &lt;code>CValueCache&lt;/code> in the other processes. An
change in one of the values in a &lt;code>CValueCache&lt;/code> is an event which must be
passed to all the other processes. All processes must observe the events
occurring in the same order, to ensure that each &lt;code>CValueCache&lt;/code> remains
consistent with the others.&lt;/p>
&lt;p>Interprocess communication via QtDBus is achieved using concrete Facade
(&amp;quot;context&amp;quot;) classes and associated Proxy classes. Slots in the
concrete class can be remotely invoked by calling the corresponding slot
of the proxy class, and signals emitted by the concrete class will be
sympathetically emitted by the proxy class. Within this framework,
events must be able to flow in any direction, from any process to any
other process or set of processes.&lt;/p>
&lt;p>The concrete class acts as central router. Using &lt;code>CSettingsCache&lt;/code> as an
example, an event enters the system when the slot
&lt;code>IContextApplication::changeSettings&lt;/code> is called. The slot arguments
describe the content of the event. If the slot is called in a proxy
class, the call will be forwarded to the concrete class as usual. The
slot in the concrete class will emit the signal
&lt;code>IContextApplication::settingsChanged&lt;/code> with the same arguments that were
passed to the slot. The corresponding signal will, as usual, be emitted
by all proxy classes in all connected processes. Successive emissions of
the signal will be always be observed in the same order by all
processes, ensuring consistency. A &lt;code>CIdentifier&lt;/code> parameter can be used
to identify the process which triggered an event, and to detect round
trips.&lt;/p>
&lt;p>The class which ultimately sends and receives the events in this example
is &lt;code>CValueCache&lt;/code>. The facade classes are responsible for establishing
the signal/slot connections, so &lt;code>CValueCache&lt;/code> has no knowledge of the
facades.&lt;/p>
&lt;h1 id="applicability">Applicability&lt;/h1>
&lt;p>Use the Relay Event pattern when a message must be sent between two or
more distributed processes in arbitrary directions. If the signal/slot
connections are established by the facades, then the classes which
ultimately send and receive the events can be completely independent of
the mechanism of interprocess communication.&lt;/p>
&lt;h1 id="structure">Structure&lt;/h1>
&lt;p>&lt;img src="http://img.swift-project.org/pattern.png" alt="image">&lt;/p>
&lt;h1 id="participants">Participants&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Abstract Facade&lt;/strong> (&lt;code>IContextApplication&lt;/code>)&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Declares a pure virtual slot (&lt;code>changeSettings&lt;/code>) and a signal
(&lt;code>settingsChanged&lt;/code>). Responsible for connecting its slot to
the Endpoint's signal (&lt;code>CValueCache::valueChangedByLocal&lt;/code>),
and for connecting its signal to the Endpoint's slot
(&lt;code>CValueCache::changeValueFromRemote&lt;/code>).&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Concrete Facade&lt;/strong> (&lt;code>CContextApplication&lt;/code>)&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Provides an implementation of the virtual slot, which emits
the signal.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Proxy Facade&lt;/strong> (&lt;code>CContextApplicationProxy&lt;/code>)&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Following the usual pattern of a facade proxy class, provides
an implementation of the virtual slot which forwards the call
to the slot of the Concrete Facade via DBus.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Endpoint&lt;/strong> (&lt;code>CValueCache&lt;/code>)&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>A class which calls the slot and/or receives the signal of the
Abstract Facade.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h1 id="collaborations">Collaborations&lt;/h1>
&lt;p>Endpoint classes (like &lt;code>CValueCache&lt;/code>) in different processes can share
events with each other when they are connected via this pattern.&lt;/p>
&lt;h1 id="consequences">Consequences&lt;/h1>
&lt;p>Endpoint classes need no knowledge of the mechanism by which their
events are passed around. They are not coupled to the Facade classes,
nor to DBus.&lt;/p>
&lt;p>The pattern results in the facades exposing a signal and a slot which
are not intended to be called directly, and should be thought of as
&lt;code>protected&lt;/code>.&lt;/p>
&lt;p>A large number of events could lead to an undesirable DBus performance
issue. This could be mitigated by more intelligently controlling which
events should be relayed.&lt;/p>
&lt;h1 id="implementation">Implementation&lt;/h1>
&lt;p>Be aware that processes may join or leave the distributed process
environment at any time. A new process joining may need special handling
to synchronize it with the processes already connected.&lt;/p>
&lt;p>Use a &lt;code>CIdentifier&lt;/code> parameter to identify the process which triggered an
event. &lt;code>CIdentifier::isFromSameProcess()&lt;/code> will return true in the case
of a round trip. There is a choice to be made, whether round trip
detection should be the responsibility of the Facade or of the Endpoint.
If the Endpoint requires confirmation that its event was received by the
Concrete Facade, then it can obtain this by doing its own round trip
detection, in which case the Facade should not do the detection.&lt;/p>
&lt;p>If events should be received only by Proxy Facades and not by the
Concrete Facade (e.g. log messages) then the Facade signal should only
be connected to the Endpoints served by the Proxy Facades. The the
signal of the Concrete Facade should be left unconnected.&lt;/p>
&lt;h1 id="known-uses">Known Uses&lt;/h1>
&lt;ul>
&lt;li>&lt;code>cache&lt;/code>{.interpreted-text role=&amp;ldquo;ref&amp;rdquo;}&lt;/li>
&lt;li>&lt;code>logging&lt;/code>{.interpreted-text role=&amp;ldquo;ref&amp;rdquo;}&lt;/li>
&lt;li>Hotkey events&lt;/li>
&lt;/ul>
&lt;h1 id="related-patterns">Related Patterns&lt;/h1>
&lt;p>Relay Event may be seen as a variation on the Mediator pattern. It could
also be thought of as a multidirectional Observer pattern in which each
Endpoint is an observer of every other Endpoint.&lt;/p>
&lt;p>Endpoint classes are often Singletons. Facade classes of course use the
Facade pattern, and Facade Proxies use the Proxy pattern.&lt;/p>
&lt;p>The Command pattern suggests encapsulating event properties into a
single value class, to avoid signals and slots with large numbers of
parameters.&lt;/p></description></item><item><title>Docs: Shared State</title><link>https://swift-project.github.io/docs/dev/sharedstate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/sharedstate/</guid><description>
&lt;h1 id="shared-state">Shared State&lt;/h1>
&lt;p>&lt;code>BlackMisc::SharedState&lt;/code> is a hierarchical library of reusable building
blocks for composing subsystems for sharing transient data between
objects, potentially in different processes.&lt;/p>
&lt;h2 id="endpoint-layer">Endpoint Layer&lt;/h2>
&lt;p>The middle layer contains the mutators and observers. Mutators and
observers correspond to commands and queries in the CQRS design pattern.
Mutators and observers can be passive and/or active, as seen in this 2x2
matrix:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th> &lt;/th>
&lt;th>Passive&lt;/th>
&lt;th>Active&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Mutator&lt;/strong>&lt;/td>
&lt;td>publishes events&lt;/td>
&lt;td>handles requests&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Observer&lt;/strong>&lt;/td>
&lt;td>subscribes events&lt;/td>
&lt;td>submits requests&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Events are fire-and-forget signals sent by passive mutators and received
by passive observers. Requests are stateful signals that expect replies;
requests are sent by active observers and received by active mutators,
which send replies back to the observers that sent the requests.&lt;/p>
&lt;p>Events and requests are sent across &amp;ldquo;channels&amp;rdquo;. Each channel can have
multiple mutators and multiple observers. Each mutator and each observer
is on exactly one channel. For an observer to communicate with a
mutator, they must both be on the same channel. Conceptually, a channel
is just a unique key string.&lt;/p>
&lt;p>These concepts are implemented by concrete
&lt;code>QObject&lt;/code> subclasses: &lt;code>CPassiveMutator&lt;/code>, &lt;code>CPassiveObserver&lt;/code>,
&lt;code>CActiveMutator&lt;/code>, &lt;code>CActiveObserver&lt;/code>. Instances of these classes are
created by calling their static &lt;code>create()&lt;/code> method, which returns a
&lt;code>QSharedPointer&lt;/code> pointing to the new object. Their channel is
determined by the &lt;code>BLACK_SHARED_STATE_CHANNEL&lt;/code> macro in the class of
their parent object, combined with the name of their parent object.&lt;/p>
&lt;h2 id="transportdatalink-layer">Transport/Datalink Layer&lt;/h2>
&lt;p>The middle layer is completely decoupled from the mechanism for
transporting events and requests. This mechanism is the responsibility
of the bottom layer. &lt;code>IDataLink&lt;/code> is an abstract interface that is
implemented by concrete subclasses to provide different transport
mechanisms. A mutator is connected by passing it to the
&lt;code>IDataLink::publish&lt;/code> method. An observer is connected by passing it to
the &lt;code>IDataLink::subscribe&lt;/code> method.&lt;/p>
&lt;h2 id="contentsubject-layer">Content/Subject Layer&lt;/h2>
&lt;p>The middle layer is also completely decoupled from the payloads carried
by the events, the requests, and the replies, which are handled by the
top layer. A payload is a &lt;code>CVariant&lt;/code>, and its contents are opaque to the
mutators and observers. It is for the parent objects of the mutators and
observers to confer meaning upon the events and requests that they send
and receive.&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>CQRS design pattern:
&lt;ul>
&lt;li>&lt;a href="http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/">http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://cqrs.nu/Faq/command-query-responsibility-segregation">http://cqrs.nu/Faq/command-query-responsibility-segregation&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://martinfowler.com/bliki/CQRS.html">http://martinfowler.com/bliki/CQRS.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="endpoints-diagram">Endpoints Diagram&lt;/h2>
&lt;p>&lt;img src="http://img.swift-project.org/sharedstate.png" alt="image">&lt;/p></description></item><item><title>Docs: Style and Coding Standard</title><link>https://swift-project.github.io/docs/dev/style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://swift-project.github.io/docs/dev/style/</guid><description>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">TODO&lt;/h4>
Need examples.
&lt;/div>
&lt;h1 id="style-conventions">Style Conventions&lt;/h1>
&lt;h2 id="whitespace-and-minutiae">Whitespace and Minutiae&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Indent with 4 spaces. Don't use tabs.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Don't indent braces. Indent code inside braces.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Put braces on a separate line.&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Exception: closing brace of a lambda, braced-initializer, or
do while block hugs the code on its right side.&lt;/li>
&lt;li>Exception: braces surrounding a braced-initializer or a
single-statement block can go all on a single line.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>When braces are not on a separate line, put a space between them and
adjacent tokens.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>No spaces around parentheses, square brackets, or angle brackets.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Put a space after a compound statement keyword (if, for, while,
etc.) and its opening parenthesis.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Always use braces in a compound statement, even if they only enclose
zero or one statement. (This helps avoid terrible mistakes.)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Put a space between a binary operator and its operand. No space
between a unary operator and its operand.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>When declaring a pointer or reference, put a space before the * or
&amp;amp;.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Write &lt;code>const char&lt;/code> not &lt;code>char const&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="naming">Naming&lt;/h2>
&lt;ul>
&lt;li>Use camel case.&lt;/li>
&lt;li>Namespaces, classes, and enums start with a capital letter.
Functions and variables starts with a lower-case letter.&lt;/li>
&lt;li>Classes begin with a &lt;code>C&lt;/code>, except traits classes which begin with a
&lt;code>T&lt;/code>.&lt;/li>
&lt;li>Data members begin with &lt;code>m_&lt;/code>. Static data members begin with &lt;code>s_&lt;/code>.
Const static data members begin with &lt;code>c_&lt;/code>. Avoid underscores
elsewhere.&lt;/li>
&lt;li>Use American English spelling.&lt;/li>
&lt;/ul>
&lt;h2 id="documentation">Documentation&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>Use &lt;code>//!&lt;/code> and &lt;code>/*!&lt;/code> style Doxygen comments.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Each header and source file has a &lt;code>//! \file&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Document classes and non-member functions with &lt;code>/*!&lt;/code>. Document
members with &lt;code>//!&lt;/code>.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Document everything that is public or protected.&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Exception: it is not necessary to document a function that
overrides a documented virtual function.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>Use &lt;code>\cond&lt;/code>, &lt;code>\private&lt;/code>, or &lt;code>\internal&lt;/code> for undocumented
implementation details at namespace scope.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Use &lt;code>\copydoc&lt;/code> to avoid duplication.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="tooling">Tooling&lt;/h2>
&lt;ul>
&lt;li>&lt;code>astyle&lt;/code> can be used with the following options:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-{.}" data-lang="{.}">--style=allman --indent=spaces=4 --indent-cases --indent-namespaces --indent-labels
--indent-preprocessor --min-conditional-indent=2 --pad-oper --pad-header --unpad-paren
--keep-one-line-blocks --keep-one-line-statements --convert-tabs --align-pointer=name
&lt;/code>&lt;/pre>&lt;h1 id="coding-standard">Coding Standard&lt;/h1>
&lt;h2 id="basics">Basics&lt;/h2>
&lt;ul>
&lt;li>Headers have include guards that are uppercase transformations of
the header path with non-alphanumeric characters transformed to
underscores.&lt;/li>
&lt;li>Include all needed headers before any substantive line of code.
Include files in order from most specific to most generic. The first
header included in a source file must be its corresponding header
file.&lt;/li>
&lt;li>Include &lt;em>swift&lt;/em> headers with &lt;code>#include &amp;quot;&amp;quot;&lt;/code>. Include other headers
with &lt;code>#include &amp;lt;&amp;gt;&lt;/code>. Always use the full path of swift headers.&lt;/li>
&lt;li>Use forward-declaration to avoid excessive includes.&lt;/li>
&lt;li>Don't &lt;code>using namespace&lt;/code> in headers.&lt;/li>
&lt;li>Don't optimize prematurely. Don't pessimize prematurely.&lt;/li>
&lt;li>Utilize Qt and the standard library liberally. Prefer Qt containers.&lt;/li>
&lt;li>Use the Qt5 pointer-to-member syntax for connecting signals to
slots.&lt;/li>
&lt;li>Respect &lt;code>const&lt;/code> correctness.&lt;/li>
&lt;li>Avoid top-level const on by-value parameter types and return types
of function declarations.&lt;/li>
&lt;li>Fix all compiler warnings.&lt;/li>
&lt;li>Pass small, trivial arguments by value. Pass large or non-trivial
arguments by &lt;code>const&lt;/code> reference.&lt;/li>
&lt;li>Don't allow uninitialized variables.&lt;/li>
&lt;li>Use RAII effectively.&lt;/li>
&lt;li>Use C++ features that are supported by all of our compilers
(currently all of C++11 and 14).&lt;/li>
&lt;li>Don't use &lt;code>NULL&lt;/code>. Use &lt;code>nullptr&lt;/code> instead.&lt;/li>
&lt;li>Use &lt;code>auto&lt;/code> at your discretion.&lt;/li>
&lt;li>Use &lt;code>override&lt;/code> when overriding a virtual function.&lt;/li>
&lt;li>Don't use &lt;code>dynamic_cast&lt;/code> or C-style casts.&lt;/li>
&lt;li>Avoid global variables. Static member variables are global
variables.&lt;/li>
&lt;/ul>
&lt;h2 id="class-design">Class Design&lt;/h2>
&lt;ul>
&lt;li>Avoid excessive coupling. Follow SOLID principles. Favor simplicity.&lt;/li>
&lt;li>Follow the rule of three/five/one/zero.&lt;/li>
&lt;li>A constructor should be &lt;code>explicit&lt;/code> if it does anything more than
just initialise members from arguments.&lt;/li>
&lt;li>If a class has a virtual function, its destructor must be virtual or
protected.&lt;/li>
&lt;li>Avoid long-distance &lt;code>friends&lt;/code>.&lt;/li>
&lt;li>Self-assignment must be safe.&lt;/li>
&lt;li>&lt;code>mutable&lt;/code> imposes a responsibility to ensure thread-safety.&lt;/li>
&lt;li>Avoid virtual functions in class templates. They cause long compile
times.&lt;/li>
&lt;li>If they are implemented, move and swap must be &lt;code>noexcept&lt;/code> if
possible.&lt;/li>
&lt;/ul>
&lt;h2 id="error-handling">Error Handling&lt;/h2>
&lt;ul>
&lt;li>Report errors and warnings to the user with &lt;code>CLogMessage&lt;/code> and
&lt;code>CStatusMessage&lt;/code>.&lt;/li>
&lt;li>Be exception-agnostic. Avoid throwing exceptions in general, except
for particular use cases where they are well suited.&lt;/li>
&lt;li>Validate data coming from outside the executable.&lt;/li>
&lt;li>Use &lt;code>Q_ASSERT&lt;/code> to document and enforce unrecoverable logical
invariants.&lt;/li>
&lt;li>Use &lt;code>BLACK_VERIFY&lt;/code> to document and enforce recoverable logical
invariants.&lt;/li>
&lt;/ul>
&lt;h2 id="strings">Strings&lt;/h2>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">TODO&lt;/h4>
Missing sections
&lt;/div></description></item></channel></rss>